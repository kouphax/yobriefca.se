--- 
layout: post
title: "Providing a Foundation for .NET Projects using NuGet"
published: true
categories: [.NET]
---
  <p>It&rsquo;s always good to have a foundation, right?&nbsp; I mean if you have a heap of projects going on or you work for a company that has a load of active or future projects then why not have a foundation?&nbsp; Foundations are good.&nbsp; I mean they promote DRY cross projects, reduce development time for many common tasks (logging, data access, etc.).&nbsp; Foundations can also provide a number of tools and technologies that are &ldquo;approved&rdquo; &mdash; that is they have been throughly researched and you aren&rsquo;t going to trip up over license issues, inexperience of the tech or shortcomings of the tech/tools.</p><p>The problem with foundations is that people start assuming they are some sort of magical framework that is supposed to do all the work.&nbsp; You wrong son!&nbsp; A foundation works best when it's a pile of techs/lightweight solutions to common problems.&nbsp; They don&rsquo;t work too well when you just get a big monolithic DLL that acts as an abstraction for other technologies.&nbsp; Abstractions are good for certain things but not everything.&nbsp; A big dll is also harder to document.&nbsp; How do you know whats in it bar using Intellisense or reflector?&nbsp; OK OK OK there should also be some sort of associated documentation that comes with it but keeping these two things inline is extra work.&nbsp; Extra work that doesn&rsquo;t get done &mdash; it&rsquo;s not funded work so why bother? Eh?</p><p>In our company we use this approach and it works from a technology perspective but from a people perspective it could be better.&nbsp; There is a general lack awareness of what is contained within the magical 3 dlls that get generated and as such less stuff get pushed into the foundation as it probably could.&nbsp; The current process works like so,</p><p class="img-holder"><img src="http://farm3.static.flickr.com/2076/5719795098_ee9676646b_b.jpg"></p><ul><li>Create a new Subversion repository for the project</li><li>Branch the current Foundation (a Visual Studio Solution) repository for the current project</li><li>Tweak the build step of the Foundation solution to dump it&rsquo;s dlls into the lib folder of the project</li><li>Commit foundation changes to the project foundation branch</li><li>Review and selectively merge changes into the trunk of the Foundation repository</li></ul><p>Even writing the steps out and thinking about all the undocumented steps required to get this to work smoothly tells me that it is possibly more complicated than it has to be.&nbsp; In fact the merging back into the Foundation trunk doesn&rsquo;t happen as much as it should.&nbsp; In fact projects adding thing to their own branch of the foundation rarely happens cause it&rsquo;s a bit messy.</p><p>Another issue with this approach is that it only makes sense for bespoke code.&nbsp; I mean if you are building out a dll how do you tell people that &ldquo;actually JSON.NET is our preferred JSON Serialiser&rdquo;.&nbsp; It&rsquo;s not easy as the documenting and announcing of such things is in another document out in the ether.</p><h2>An Alternative Approach</h2><p>Modular.&nbsp; It&rsquo;s the future I tell thee!&nbsp; Discrete pieces of functionality that can run independently.&nbsp; This enables project to take the parts of the foundation they want and build a framework from it.&nbsp; Much like ender (<a href="http://ender.no.de/">http://ender.no.de/</a>) is doing in the JavaScript world currently being able to take micro-libraries and build a macro-framework that suits your needs and just that.&nbsp; No risk of featureitis, evolve your framework as you need and be in complete control doing it.</p><p class="img-holder"><img src="http://farm4.static.flickr.com/3045/5719234363_1b5f04b781_z.jpg"></p><p>Thats the plan but how do we achieve it?&nbsp; HINT: The answer, a partial one anyway, is in the title of this post.&nbsp; Well, first things first we would need to take our current foundation and modularise it.&nbsp; Along with that we&rsquo;d probably need to ensure tests etc. are up to scratch (start on the right foot).&nbsp; Secondly we would need to change the delivery mechanism - no more branching and merging of codebases - too heavyweight.&nbsp; NuGet (<a href="http://nuget.codeplex.com">nuget.codeplex.com</a>) will help.&nbsp; With NuGet we could create packages from our modules, manage dependencies, document usage right in the package manifest, and expose these packages as a server and searchable package repository (a la <a href="http://www.nuget.org">nuget.org</a>).&nbsp; Into this repository we could push all our approved technologies (researched and vetted previously) as well as new versions of our bespoke code.&nbsp; As time goes on this repository can grow and more people can add to it.&nbsp; Heck we can even make the submission process as easy as we see on nuget.org.&nbsp; Wunderbar!</p><p>So how would this affect how projects operate on a daily basis?</p><p class="img-holder"><img src="http://farm4.static.flickr.com/3532/5719234439_0171705928_z.jpg"></p><p>Well the mechanism for the typical usage is greatly simplified.&nbsp; The project pushes and pulls packages from a central package repo.&nbsp; People use the repo to search for things they need (JSON Serialiser, Micro-ORM etc) and if they don&rsquo;t find something they can then push a new package into the repo (or just suggest one).&nbsp; Self documenting use of 3rd party techs, all available all searchable.</p><p>Another advantage of this approach, and using NuGet in particular, allows us to bundle not just dlls but also transform files for configuration (web.xml etc.), javascript/css/other client side assets, project and solution wide tools (executable that can be run from the VS command prompt etc.) and even code samples and templates. &nbsp;This gives us a richer, more cohesive delivery mechanism for a foundation to a project.</p><p>Of course it&rsquo;s not all perfect.&nbsp; Urgent changes to bespoke code will need to be done the old fashioned way and pushed to the main server which is less than ideal but it&rsquo;s a bit of an edge case.</p><p>So whats not to like about this idea?&nbsp; Foundations not frameworks is the key here.&nbsp; Let the project create its own framework as that will work much better than imposing one upon them.</p><p>So this is a bit of a brain dump (some would say brain fart no doubt) as usual and I am open to suggestions and corrections.&nbsp; I&rsquo;ve likely missed a few glaring problems with the new approach so let the critics loose and I&rsquo;ll try my best to address their concerns.</p><p>Next step - setting up a simple POC to test the general workflow.</p>