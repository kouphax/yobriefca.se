--- 
layout: post
title: "Client Side: Processing vs Responsiveness"
published: true
categories: [JavaScript, Web]
---
  <p style="padding-left: 30px;"><em>The examples below are probably best run in a browser that has a relatively slow script engine (IE for example)</em></p><p>One of the problem with the whole Web2.0/Rich Client concepts is that people seem to think it&rsquo;s OK to shove processing that should be done on the server on to the client. This is never the answer &ndash; you can control resources on the sever but never on some random browser half way across the world/country/street/room. There are, however, situations where client side processing is going to be mandatory (think Complex Grids and Calculations etc). This obviously leads to a loss of responsiveness on the client (to varying degrees). One of the big problem with large processing is that it obviously takes time. Imagine this scenario&hellip;</p><p><script src="https://gist.github.com/635921.js"></script></p><p>You&rsquo;d expect that this code updates the &ldquo;progress-meter&rdquo; element with &ldquo;Processing&rdquo;, does some long computation and then updates the &ldquo;progress-meter&rdquo; again to indicate it&rsquo;s done. But it doesn&rsquo;t. Screen repaints/updates do not happen until calls complete. So what is actually happening? Well the expected outcome DOES happen it&rsquo;s just both updates happen after the call completes so the first update occurs so fast you never see it.&nbsp;<a href="http://jsfiddle.net/kouphax/VtaHg/" target="_blank">See It In Action</a>. You&rsquo;ll also notice that the entire screen is locked while this processing occurs and that just leads to a bad user experience. So what can be done?</p><h2>Use of setTimeout()</h2><p>Javascript is single threaded which leads to the issues above but there is a way create pseudo-threading using setTimeout. The setTimeout function executes code after a set time in milliseconds (what a surprise!). So delaying this execution (even by 0 miilliseconds) allows screen updates to occur before the processing begins. This requires a small change to the code.</p><p><script src="https://gist.github.com/635922.js"></script></p><p>So if you&nbsp;<a href="http://jsfiddle.net/kouphax/MJFFX/" target="_blank">give this a go</a>&nbsp;you will see there is a much better feedback response compared to the first. This approach solves our initial problem but we still have the issue that the screen is locking up. At least now the users knows something is happening. Another issue this creates is that some browsers prompt users if scripts take to long allowing the user to cancel potentially important tasks.</p><p>[[posterous-content:jcdDmwFBuEneeneritwd]]</p><h2>Asynchronous Processing</h2><p>Now we are getting into the good stuff. To prevent the screen locking up during any complex processing activity it is possible to apply the setTimeout technique but only over a smaller subset of the processing activity each time. This will achieve a sort of asynchronous effect allowing the user to do other stuff while the processing happens in the background. This is a basic example,</p><p><script src="https://gist.github.com/635923.js"></script></p><p>You can&nbsp;<a href="http://jsfiddle.net/kouphax/CKALu/" target="_blank">see this in action</a>&nbsp;for yourself. If you run the example you will see that there is a constant update (after each chunk is processed) and that screen control is still available. So this has solved both our issues but has introduced new considerations.</p><ul><li>Executes asynchronously therefore we need to support a callback mechanism as it&rsquo;s not procedural (see code)</li><li>Processing time increases (see below)</li></ul><p>You will see that the length of time it take to process the complete task is a lot longer than the other 2 examples.. this is due to the increase in complexity of the code (recursion, another function call etc) and this is the trade off. Processing time is inversely proportional to the size of each processing chunk</p><div>[[posterous-content:ImAAruEoruBBGBGeBetI]]<p>Chunk Size (y) vs Response Time (x)</p></div><p><br>As the chunk sizes get smaller you get a more responsive UI but the processing time can get scarily long. The example chunks at about 1% of the total task size and that seems to be a good balance (for this task at least) between responsiveness and processing time. I threw together a little suite of yielding techniques with various update times etc and you can play around with that&nbsp;<a href="http://jsfiddle.net/kouphax/Kkhc9/" target="_blank">here</a></p>