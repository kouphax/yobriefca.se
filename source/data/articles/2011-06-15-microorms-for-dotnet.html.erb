---
layout: post
published: true
title: "MicroORMs for .NET: (Obligatory) Introduction (Post)"
categories: [".NET"]
---
  <blockquote class="announce">This post is the is part of series of posts covering the various microORMs in the .<span class="caps">NET</span> world.  I intend to look at how each microORM meets certain data access and manipulation needs.  The current series includes,<ul>	<li><a href="http://yobriefca.se/blog/2011/06/15/microorms-for-net-obligatory-introduction-post">Obligatory Introduction Post</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/16/microorms-for-net-syntax-selects">Syntax &#8211; SELECTs</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/18/microorms-for-net-stored-procedures">Stored Procedures</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/21/microorms-for-net-inserts-updates-and-delete">Inserts, Updates &amp; Deletes</a><br></li></ul></blockquote><p>I&#8217;ve been playing, somewhat superficially, with a few MicroORMs in .<span class="caps">NET</span> for a while now.  While I have yet to use any in a real project I wanted to do a bit of comparison series.  It&#8217;s a bit selfish I guess as I am actually writing this series as a means to get myself up to speed on these frameworks as well as inform others about perils I faced as a newcomer to them as and when I hit those pain points.</p><p>To be honest I&#8217;ve never been a fan of the Data Access layer in projects &#8211; Databases are fine I guess and the application layer is all good but that thin layer between the two just frustrates me.  It&#8217;s often needlessly over complicated, confusing, hacked together or just plain broken.  Most of my experience is with <a href="http://www.mybatis.org/dotnet.html">iBatis/MyBatis</a> and it &#8220;does the job&#8221; but its very fiddly and <span class="caps">XML</span> configuration becomes cumbersome for simple tasks.  I&#8217;ve also tinkered with other things like Entity Framework and NHibernate but more often than not they just don&#8217;t feel right.</p><p>This make microORMs sound appealing to me for the very same reasons.  They give you just enough to get the job done, prefer convention over configuration and generally allow you to get right down to the metal and tweak things using <span class="caps">SQL</span> &#8211; easily the best <span class="caps">DSL</span> for working with databases.  Sure they may lack many features but typically these are features you wouldn&#8217;t really miss if taken away from you.</p><h2>The MicroORMs</h2><p>There are a number of ORMs currently available for .<span class="caps">NET</span> and I am going to look at a few of them in terms of features and syntax.<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></p><h3><a href="http://code.google.com/p/dapper-dot-net/">Dapper</a></h3><p>Dapper was created by Sam Saffron from <a href="http://stackoverflow.com">Stackoverflow</a>. Rather than a library Dapper is a single file that you can drop into your project and applies some syntactic sugar to extend your IDbConnection interface.</p><h3><a href="https://github.com/robconery/massive">Massive</a></h3><p>Like Dapper, Massive is a single file rather than a library and offers a very similar feature set to Dapper except it works exclusively with the .NET4 <code>dynamic</code> stuff.</p><h3><a href="http://www.toptensoftware.com/petapoco/">PetaPoco</a></h3><p>PetaPoco came out of inspiration from Massive and has extended to support real objects as well as some very nice extra features such as T4 templating, configuration via model attributes and other nice stuff.</p><h3><a href="https://github.com/markrendle/Simple.Data">Simple.Data</a></h3><p>Simple.Data is A lightweight, dynamic data access component that make use of convention and <code>dynamic</code> to allow users to access database tables via dynamically generated methods.</p><h3><a href="https://github.com/ServiceStack/ServiceStack.OrmLite">ORMLite</a></h3><p>ServiceStack.OrmLite is a convention-based, configuration-free lightweight <span class="caps">ORM</span> that uses standard <span class="caps">POCO</span> classes and Data Annotation attributes to infer its table schema.</p><h2>On with the show</h2><p>So thats my toys all laid out and ready to be played with.  Next step is to look at some of the typical operations for selecting and manipulating data from our database.  I hope to have the first real part of this investigation up shortly (or before the decade is out at least).</p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> This list is not exhaustive there are a few specialised ones around as well which I may touch on later in the series.</p>