---
date: 2011-06-17T23:00:00Z
title: 'MicroORMs for .NET: Stored Procedures'
published: true
categories: [.NET]
type: article
external: false
---
<blockquote class="announce">This post is the is part of series of posts covering the various microORMs in the .<span class="caps">NET</span> world.  I intend to look at how each microORM meets certain data access and manipulation needs.  The current series includes,<ul>	<li><a href="http://yobriefca.se/blog/2011/06/15/microorms-for-net-obligatory-introduction-post">Obligatory Introduction Post</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/16/microorms-for-net-syntax-selects">Syntax - SELECTs</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/18/microorms-for-net-stored-procedures">Stored Procedures</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/21/microorms-for-net-inserts-updates-and-delete">Inserts, Updates &amp; Deletes</a><br /></li></ul></blockquote><p>As handy as running straight, fully-tailored SELECTs straight from your app code a lot of the time, especially in the "enterprise" world your <span class="caps">DBA</span> is going to insist that all operations go through tightly controlled stored procedures.  It's all for the greater good I'm sure but flipsake it's bloody annoying.</p><div style="font-family:&quot;Courier New&quot;, Courier;color:#0b0;background-color:black; padding:1px 20px;font-size:0.9em;margin-left:20px;margin-right:20px;"><p><em>You are standing at the edge of a forest.  Ahead of you an old wooden sign sits at a slight angle.</em></p><p><strong>&gt;&gt; read sign</strong></p><p><em>You squint your eyes as you approach the sign and read the fading writing.  The sign reads</em></p><p style="padding-left:1em;"><em>"Welcome to the forest of microORMs.  You have nice eyes.  Have a <span class="caps">GREAT</span> day."</em></p><p><strong>&gt;&gt; enter forest</strong></p><p><em>You walk, nay skip, into the forest.  A few minutes in you are confronted with a horribly gnarled beast.  The grumpy looking thing seems very out of place in this land of near tranquilty.  As you approach, it speaks</em></p><p style="padding-left:1em;"><em>"<span class="caps">GROAN</span> <span class="caps">GRUNT</span> Control <span class="caps">GROWL</span> Best Practise <span class="caps">WHEEZE</span> Enterprise Ready <span class="caps">SNARL</span>.  Little being... you may not pass any way you please.  That is not how we do things <span class="caps">GRUMBLE</span> <span class="caps">WHEEZE</span>. No to pass this way meatbag you must, yes must, take this route I have planned for you.  If you need to change your route I must approve it and construct it <span class="caps">COUGH</span> <span class="caps">GRUMBLE</span>.  There is limited scenery and not too many points to have fun"</em></p><p><strong>&gt;&gt; kill beast</strong></p><p><em>I'm afraid I can't do that</em></p><p><strong>&gt;&gt; fffffffffffffffffffff..</strong></p></div><p>Fear not help is at hand.  So can we call sprocs using our microORMs, and if yes how?  Lets go see shall we?<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></p><h2>Dapper</h2><p>Dapper makes use of an extra parameter in its <code>Query&lt;T&gt;</code> method to specify a specific command type.  In this way it's simply a matter of passing in the name of the sproc, the parameters and a <code>CommandType.StoredProcedure</code> as a named parameter.</p><p class="minimal-gist"></p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">author</span> <span class="p">=</span> <span class="n">conn</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span>
    <span class="s">"GetAuthorById"</span><span class="p">,</span>
    <span class="k">new</span> <span class="p">{</span> <span class="n">Id</span> <span class="p">=</span> <span class="m">1</span> <span class="p">},</span>
    <span class="n">commandType</span><span class="p">:</span> <span class="n">CommandType</span><span class="p">.</span><span class="n">StoredProcedure</span>
<span class="p">).</span><span class="n">First</span><span class="p">();</span>
</code></pre></div>
<p>And boom thats it.  Same applies for multiple results.</p><h2>Massive</h2><p>Massive just works.</p><p class="minimal-gist"></p><div class="highlight"><pre><code><span class="kt">dynamic</span> <span class="n">dyn</span> <span class="p">=</span> <span class="n">tbl</span><span class="p">.</span><span class="n">Query</span><span class="p">(</span><span class="s">"GetAuthorById @0"</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="n">First</span><span class="p">();</span>
</code></pre></div>
<p>All I did was swap out the <span class="caps">SELECT</span> statement for the name of the sproc and Bobs Your Uncle.  Nice.</p><h2>PetaPoco</h2><p>PetaPoco has <em>some</em> support for sprocs.  For my needs in this article it works fine but apparently it doesn't support output parameters <span class="caps">ATM</span>.  You need to prepend your call to the sproc with a DB specific command.</p><p class="minimal-gist"></p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">a</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span><span class="s">"EXECUTE GetAuthorById @0"</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="n">First</span><span class="p">();</span>
</code></pre></div>
<p>The <code>EXECUTE</code> statement is database specific.  If you are using MySql you need to use <code>CALL</code> instead which kind of starts breaking the abstraction a bit.  I wonder if we will see this support getting more solidified in future releases.</p><h2>ServiceStack ORMLite</h2><p>At the time of writing this I couldn't see any built in support for sprocs using ORMLite.  Either I am being my typical clueless self or we would just have to do it by hand.  Here is what I came up with,</p><p class="minimal-gist"><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">author</span> <span class="p">=</span> <span class="n">dbFactory</span><span class="p">.</span><span class="n">Exec</span><span class="p">(</span><span class="n">dbCmd</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">dbCmd</span><span class="p">.</span><span class="n">CommandType</span> <span class="p">=</span> <span class="n">CommandType</span><span class="p">.</span><span class="n">StoredProcedure</span><span class="p">;</span>
    <span class="n">dbCmd</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">SqlParameter</span><span class="p">(</span><span class="s">"@id"</span><span class="p">,</span> <span class="m">1</span><span class="p">));</span>
    <span class="n">dbCmd</span><span class="p">.</span><span class="n">CommandText</span> <span class="p">=</span> <span class="s">"GetAuthorById"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">dbCmd</span><span class="p">.</span><span class="n">ExecuteReader</span><span class="p">().</span><span class="n">ConvertTo</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;();</span>
<span class="p">});</span>
</code></pre></div>
</p><p>It's not exactly the worst thing in the world and I guess you could wrap this stuff in an extension method but still I feel spoilt by the other microORMs so far and this was a slight disappointment.  Perhaps someone could either confirm or deny sproc support in ORMLite?</p><h2>Simple.Data</h2><p>Simple.Data has lovely syntax for this.  You just call it as yet another dynamic method on the database object and Simple.Data just infers it for you.</p><p class="minimal-gist"></p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">author</span> <span class="p">=</span> <span class="n">Simple</span><span class="p">.</span><span class="n">Data</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">Open</span><span class="p">().</span><span class="n">GetAuthorById</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">First</span><span class="p">();</span>
</code></pre></div>
<p>Yeah thats nice.</p><h2>Slightly Shorter and Summing Up</h2><p>So I didn't want this one to have too much waffle (bar the odd text adventure here and there).  I was concerned that perhaps calling sprocs might be one of those requirements were the whole microORM stuff starts falling apart but no.  They actually handle the whole thing in a nice, clean manner.</p><p>Simple.Data is certainly starting to look more appealing to me and the whole fact that it's not database specific (you've got NoSQL stores and even experimental things such as a Registry adapter - imagine this as part of Powershell).</p><p>Anyway some code snippets for this stuff are currently available in the <a href="https://github.com/kouphax/microorm-comparison">project/series github repo</a></p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> Not a real game.</p>