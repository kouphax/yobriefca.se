---
date: 2011-06-15T23:00:00Z
title: 'MicroORMs for .NET: Syntax - SELECTs'
published: true
categories: [.NET]
type: article
external: false
---
<blockquote class="announce">This post is the is part of series of posts covering the various microORMs in the .<span class="caps">NET</span> world.  I intend to look at how each microORM meets certain data access and manipulation needs.  The current series includes,<ul>	<li><a href="http://yobriefca.se/blog/2011/06/15/microorms-for-net-obligatory-introduction-post">Obligatory Introduction Post</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/16/microorms-for-net-syntax-selects">Syntax - SELECTs</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/18/microorms-for-net-stored-procedures">Stored Procedures</a></li>	<li><a href="http://yobriefca.se/blog/2011/06/21/microorms-for-net-inserts-updates-and-delete">Inserts, Updates &amp; Deletes</a><br /></li></ul></blockquote><p>The two main things I want to look at in this article are</p><ol>	<li>Syntax of the microORM, specifically around,</li>	<li>Selecting single and multiple results</li></ol><p>So the most obvious starting point, bar the <a href="../15/microorms-for-net-obligatory-introduction-post/">boring introduction</a>, is how you perform selects using these awesome thingies.  To begin with lets get our playground set up.  Lets create a table of authors, lets call it <code>Authors</code><sup class="footnote" id="fnr0"><a href="#fn0">0</a></sup></p><div class="highlight"><pre><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Authors</span><span class="p">(</span>
  <span class="n">Id</span>          <span class="nb">int</span>          <span class="k">IDENTITY</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">Username</span>    <span class="nb">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>                <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">FullName</span>    <span class="nb">varchar</span><span class="p">(</span><span class="mi">250</span><span class="p">)</span>               <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">CreatedDate</span> <span class="n">datetime</span>                   <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>

 <span class="k">CONSTRAINT</span> <span class="n">PK_Authors</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="n">CLUSTERED</span> <span class="p">(</span><span class="n">Id</span> <span class="k">ASC</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>
<p>And populate it with some (meaningless) data<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>,</p><div class="highlight"><pre><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Authors</span><span class="p">(</span><span class="n">Username</span><span class="p">,</span> <span class="n">FullName</span><span class="p">,</span> <span class="n">CreatedDate</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'0@example.com'</span><span class="p">,</span> <span class="s1">'James Red'</span><span class="p">,</span> <span class="n">GETDATE</span><span class="p">());</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Authors</span><span class="p">(</span><span class="n">Username</span><span class="p">,</span> <span class="n">FullName</span><span class="p">,</span> <span class="n">CreatedDate</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'1@example.com'</span><span class="p">,</span> <span class="s1">'Harry Black'</span><span class="p">,</span> <span class="n">GETDATE</span><span class="p">());</span>
<span class="c1">-- ...CROPPED FOR BREVITY...</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Authors</span><span class="p">(</span><span class="n">Username</span><span class="p">,</span> <span class="n">FullName</span><span class="p">,</span> <span class="n">CreatedDate</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'134@example.com'</span><span class="p">,</span> <span class="s1">'Chloe Green'</span><span class="p">,</span> <span class="n">GETDATE</span><span class="p">());</span>
</code></pre></div>
<p>Finally we need to create the equivalent C# object that our results can map to.  Again nothing too crazy here,</p><div class="highlight"><pre><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Author</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Username</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FullName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">DateTime</span> <span class="n">CreatedDate</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>So now the stage is set and it's time for our microORMs to play their part.</p><h2>Selecting Single and Multiple Authors</h2><p>So lets assume we want to do 2 things -</p><ul>	<li>Select a single author with an Id of 1, and,</li>	<li>Select multiple authors whose username (in this case the users email address) ends with <em>example.com</em>.</li></ul><h3>Dapper</h3><p>Dapper has a single way of querying your database and it offers this via an extension method on the standard <code>SqlConnection</code> class,</p><div class="highlight"><pre><code><span class="k">using</span> <span class="p">(</span><span class="n">SqlConnection</span> <span class="n">conn</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SqlConnection</span><span class="p">(</span><span class="n">ConnectionString</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">conn</span><span class="p">.</span><span class="n">Open</span><span class="p">();</span>
    <span class="n">Author</span> <span class="n">a</span> <span class="p">=</span> <span class="n">conn</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span>
        <span class="s">"SELECT * FROM Authors WHERE Id = @Id"</span><span class="p">,</span> 
        <span class="k">new</span> <span class="p">{</span> <span class="n">Id</span> <span class="p">=</span> <span class="m">1</span> <span class="p">}).</span><span class="n">First</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>As you can see I've just opened a normal connection using a ConnectionString property I pulled from my <code>App.config</code>'s ConnectionString config block.  The magic here lies in the <code>Query&lt;Author&gt;</code> method.  This method accepts a parameterised <span class="caps">SQL</span> string and maps the result back into the object you specified.  Ultra simple, ultra clean.  There are a whole host of other arguments to the <code>Query&lt;T&gt;</code> method but it would fill this post up pretty fast.</p><p>Selecting multiple object simply requires me to change the query to meet the new requirements,</p><div class="highlight"><pre><code><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;</span> <span class="n">dapperA</span> <span class="p">=</span> <span class="n">conn</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span>
    <span class="s">"SELECT * FROM Authors WHERE Username LIKE @PartialUsername"</span><span class="p">,</span>
    <span class="k">new</span> <span class="p">{</span> <span class="n">PartialUsername</span> <span class="p">=</span> <span class="s">"%example.com"</span> <span class="p">});</span>
</code></pre></div>
<p>One of the features I really liked apart from the simplicity of the whole thing was the parameterised <span class="caps">SQL</span>.  Many of the frameworks support this but most support it by index based assignment e.g. "<span class="caps">WHERE</span> Id=@0".  Thats fine but Dappers use of an anonymous object makes the whole thing that little bit nicer. No need to refactor strings should your arguments move around (it has happened) and it all reads just that tiny bit better as well.</p><p>Dapper also offers a non-generic <code>Query</code> method that returns instances of <code>dynamic</code> objects but I'm still to be convinced that this is useful when pushing these models into and back out of views etc.  Still it's nice to have for those times that creating another model would be overkill.</p><h3>Massive</h3><p>Massive is slightly different to the other microORMs in that it only deals with <code>dynamic</code> objects from queries.  This means if you need concrete models you will have to map them either manually or use a tool to help (such as <a href="http://automapper.codeplex.com/">AutoMapper</a>).  Due to my schema (pluarl table names) I use Massive in a slightly different way to most people.  Massive requires your models to extend <code>Massive.DynamicModel</code> so to keep things clean I tended to naturally create a model that represents my Authors table,</p><div class="highlight"><pre><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Authors</span> <span class="p">:</span> <span class="n">Massive</span><span class="p">.</span><span class="n">DynamicModel</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">Authors</span><span class="p">()</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="s">"DefaultConnectionString"</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PrimaryKeyField</span> <span class="p">=</span> <span class="s">"Id"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This provides an entry point for configuring how Massive connects to your database.  The <code>DynamicModel</code> has a constructor that allows us to specify a connection string name that Massive will lookup from the <code>Web/App.config</code> <code>ConnectionStrings</code> config section.  Alternatively if you don't supply this Massive will grab the first one it finds.  This class also allows us to specify the table name (in this case inferred from the class name) and properties such as the primary key of the table (as shown above).</p><p>Now we have our class defined we can start selecting from the database.  To select a single object we can use the <code>Single</code> method.</p><div class="highlight"><pre><code><span class="n">Authors</span> <span class="n">table</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Authors</span><span class="p">();</span>
<span class="kt">dynamic</span> <span class="n">result</span> <span class="p">=</span> <span class="n">table</span><span class="p">.</span><span class="n">Single</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
<span class="n">Author</span> <span class="n">author</span> <span class="p">=</span> <span class="n">Authors</span><span class="p">.</span><span class="n">Map</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</code></pre></div>
<p>You'll notice I've made another step here and that is mapping the <code>dynamic</code> result to a concrete <code>Author</code> object.  It's a simple mapping method added to the <code>Authors</code> object but could be made more generic fairly easiy,</p><div class="highlight"><pre><code><span class="k">public</span> <span class="k">static</span> <span class="n">Author</span> <span class="nf">Map</span><span class="p">(</span><span class="kt">dynamic</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Author</span>
    <span class="p">{</span>
        <span class="n">Id</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span>
        <span class="n">CreatedDate</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">CreatedDate</span><span class="p">,</span>
        <span class="n">FullName</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">FullName</span><span class="p">,</span>
        <span class="n">Username</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">Username</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>Selecting multiple objects can be done in 2 ways using <code>All</code> which returns the entire table and then you filter or using the <code>Query</code> method (preferred unless you really want to return the entire table for refdata or something I guess)</p><div class="highlight"><pre><code><span class="kt">var</span> <span class="n">tbl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Authors</span><span class="p">();</span>
<span class="n">IList</span><span class="p">&lt;</span><span class="kt">dynamic</span><span class="p">&gt;</span> <span class="n">dyn</span> <span class="p">=</span> <span class="n">tbl</span><span class="p">.</span><span class="n">Query</span><span class="p">(</span>
    <span class="s">"SELECT * FROM Authors WHERE Username LIKE @0"</span><span class="p">,</span> 
    <span class="s">"%example.com"</span><span class="p">);</span>
</code></pre></div>
<div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> Rob, the creator of Massive, has just pushed <a href="http://wekeroad.com/post/6618062904/changed-my-mind-massive-changed-to-embrace-c">a new type of query syntax</a> into Massive.  The new approach makes use of named parameters</p><div class="highlight"><pre><code><span class="kt">dynamic</span> <span class="n">db</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Products</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">products</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">FindBy</span><span class="p">(</span>
    <span class="n">CategoryID</span><span class="p">:</span><span class="m">8</span><span class="p">,</span>
    <span class="n">UnitPrice</span><span class="p">:</span><span class="m">100</span>
<span class="p">);</span>
</code></pre></div>
<p>I haven't rewritten my stuff in this post but I want to close this post off and move on.  There is plenty more info in the <a href="http://wekeroad.com/post/6618062904/changed-my-mind-massive-changed-to-embrace-c">original post</a></p></div><h3>PetaPoco</h3><p>PetaPoco has a number of way of selecting single objects, or more specifically multiple ways of building/manipulating <span class="caps">SQL</span> queries.  But before we do that we need to get access to the database.  We do this via the <code>PetaPoco.Database</code> object which is an <code>IDisposable</code> wrapper around a Database connection that gives us the PetaPoco magic.</p><div class="highlight"><pre><code><span class="k">using</span> <span class="p">(</span><span class="n">PetaPoco</span><span class="p">.</span><span class="n">Database</span> <span class="n">db</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PetaPoco</span><span class="p">.</span><span class="n">Database</span><span class="p">(</span><span class="s">"DefaultConnectionString"</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// query goes here</span>
<span class="p">}</span>
</code></pre></div>
<div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> <a href="http://twitter.com/toptensoftware">Brad Robinson</a> has informed me that the <code>using</code> statement is unnecessary</p><blockquote><p>You don't need to explicitly dispose the database object unless you've called OpenSharedConnection yourself. The idea is that if you're using an <span class="caps">IOC</span> container to instantiate per-http-context instances you can call OpenSharedConnection at the start of the request and a single connection will be used for the entire http request. In practice I've found this not really necessary as most providers do connection pooling anyway. In other words, generally the using clause is not necessary.</p></blockquote></div><p>The Database constructor takes a name of a defined connection string to use for connecting to the database.  Now we are ready to start writing our query,</p><p><strong>Using Single(id)</strong></p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">a</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Single</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">);</span>
</code></pre></div>
<p><strong>Using Custom Parameterised <span class="caps">SQL</span></strong></p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">b</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Single</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span><span class="s">"SELECT * FROM Authors WHERE Id = @0"</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
</code></pre></div>
<div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> <a href="http://twitter.com/toptensoftware">Brad Robinson</a> pointed out that it is also possible to used named parameters as discussed in the Dapper section above <code>@MyNamedParam</code> instead of <code>@0</code>.  The niceness just keeps coming with PetaPoco</p></div><p><strong>Using <span class="caps">SQL</span> Builder to Append Statements</strong></p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">c</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Single</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span>
    <span class="n">PetaPoco</span><span class="p">.</span><span class="n">Sql</span><span class="p">.</span><span class="n">Builder</span>
        <span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">"SELECT * FROM Authors"</span><span class="p">)</span>
        <span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">"WHERE Id = @0"</span><span class="p">,</span> <span class="m">1</span><span class="p">));</span>
</code></pre></div>
<p><strong>Using <span class="caps">SQL</span> Builders Fluent Syntax to Append Statements</strong></p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">d</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Single</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span>
    <span class="n">PetaPoco</span><span class="p">.</span><span class="n">Sql</span><span class="p">.</span><span class="n">Builder</span>
        <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="s">"*"</span><span class="p">)</span>
        <span class="p">.</span><span class="n">From</span><span class="p">(</span><span class="s">"Authors"</span><span class="p">)</span>
        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="s">"Id = @0"</span><span class="p">,</span> <span class="m">1</span><span class="p">));</span>
</code></pre></div>
<p>See what I mean?  Lots of ways.  Now I guess the 3rd and 4th methods will probably seem a bit <acronym title="Over The Top"><span class="caps">OTT</span></acronym> for this simple select but think how powerful these would be if we had to conditionally build up our where clause or select statement based on a number of user defined conditions.  Nice.</p><p>Selecting multiple objects offers the same sort of variety except we can use either <code>Query</code> or <code>Fetch</code>.  The difference between the two is summed up by the PetaPoco site,</p><blockquote><p>These are pretty much identical except <code>Fetch</code> returns a List&lt;&gt; of POCO's whereas <code>Query</code> uses <code>yield return</code> to iterate over the results without loading the whole set into memory.</p></blockquote><p>So what I say about <code>Query</code> applies to <code>Fetch</code> as well.  Retrieving multiple objects is done in the same way as selecting a single object in that you can give the method parameterised <span class="caps">SQL</span> or use the <span class="caps">SQL</span> builder to construct the query.</p><div class="highlight"><pre><code><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;</span> <span class="n">authors</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span>
    <span class="s">"SELECT * FROM Authors WHERE Username LIKE @0"</span><span class="p">,</span> 
    <span class="s">"%example.com"</span><span class="p">);</span>
</code></pre></div>
<p>So to cover this off a full select using PetaPoco will would look like this.</p><div class="highlight"><pre><code><span class="k">using</span> <span class="p">(</span><span class="n">PetaPoco</span><span class="p">.</span><span class="n">Database</span> <span class="n">db</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PetaPoco</span><span class="p">.</span><span class="n">Database</span><span class="p">(</span><span class="s">"DefaultConnectionString"</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">Author</span> <span class="n">q</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Single</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span><span class="s">"SELECT * FROM Authors WHERE Id = @0"</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><span class="caps">IMO</span> The syntax is nice, clean and flexible.  One thing about PetaPoco that is a <span class="caps">VERY</span> minor pain point for me is that it assumes singular name for tables which contradicted my earlier decision.  Not to worry PetaPoco uses attributes against the model class to manipulate the standard configuration and I can specify a class level attribute of <code>[PetaPoco.TableName("Authors")]</code> to put things right with the world.  This also only applies to the queries that use object inference such as <code>Single&lt;T&gt;</code> and not to the methods that accept <span class="caps">SQL</span>.</p><h3>ServiceStack ORMLite</h3><p>ORMLite from ServiceStack does things a wee bit differently to the rest.  It's a bit less self-contained because it also applies extension methods to the string object as well.  Also like PetaPoco it takes the singular naming convention for Object Name &rarr; Table Name so first things first we need to annotate our <code>Author</code> model with another attribtue</p><div class="highlight"><pre><code><span class="na">[ServiceStack.DataAnnotations.Alias("Authors")]</span>
</code></pre></div>
<p>Another thing we need to do once before hand is set the dialect the ORMLite will use.  This is so it knows how to speak to the specific database type we created.  Typically you would put this in something like <code>Global.asax.cs</code>, <code>Program.cs</code> or whatever bootstrapper you care to use as it needs done only once.</p><div class="highlight"><pre><code><span class="n">OrmLiteConfig</span><span class="p">.</span><span class="n">DialectProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SqlServerOrmLiteDialectProvider</span><span class="p">();</span>
</code></pre></div>
<p>Now we can go ahead and start selecting things like a boss,</p><div class="highlight"><pre><code><span class="k">using</span> <span class="p">(</span><span class="n">IDbConnection</span> <span class="n">db</span> <span class="p">=</span> <span class="s">"..."</span><span class="p">.</span><span class="n">OpenDbConnection</span><span class="p">())</span>
<span class="k">using</span> <span class="p">(</span><span class="n">IDbCommand</span> <span class="n">cmd</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">CreateCommand</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Author</span> <span class="n">rows</span> <span class="p">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">GetById</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>And for selecting many</p><div class="highlight"><pre><code><span class="k">using</span> <span class="p">(</span><span class="n">IDbConnection</span> <span class="n">db</span> <span class="p">=</span> <span class="n">Program</span><span class="p">.</span><span class="n">ConnectionString</span><span class="p">.</span><span class="n">OpenDbConnection</span><span class="p">())</span>
<span class="k">using</span> <span class="p">(</span><span class="n">IDbCommand</span> <span class="n">cmd</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">CreateCommand</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">List</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;</span> <span class="n">rows</span> <span class="p">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;(</span>
        <span class="s">"Username LIKE {0}"</span><span class="p">,</span> 
        <span class="s">"%example.com"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Alternatively if we want to perform a specific operation on each result we can use the <code>Each&lt;T&gt;</code> to iterate over the result set rather than simply return it.</p><p>As you can see you don't need to specify a full <span class="caps">SQL</span> query, just the <span class="caps">WHERE</span> clause which makes everything look a little bit neater and avoids repeating unnecessary portions of <span class="caps">SQL</span> that could be inferred.</p><p>ORMLite's syntax is <em>slighlty</em> more complex - it feels a bit closer to the metal.  But it's certainly not horribly different that it would put me off using it.</p><div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> It seems there is another way to query the database that makes things a bit shorter.  Thanks to mythz (in the comments) for this one.</p><div class="highlight"><pre><code>removed by original author :(
</code></pre></div>
<p>I agree that this is a viable alternative and can make for shorter code.  Thanks.</p></div><h3>Simple.Data</h3><p>Finally Simple.Data offers a very clean syntax that mixes dynamic with concrete results.  The first thing you need to do with Simple.Data is get a handle on the Database object that is returned as a special <code>dynamic</code> object.  There are a number of ways of doing this,</p><div class="highlight"><pre><code><span class="n">Simple</span><span class="p">.</span><span class="n">Data</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">Open</span><span class="p">();</span>
<span class="n">Simple</span><span class="p">.</span><span class="n">Data</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">OpenNamedConnection</span><span class="p">(</span><span class="s">"DefaultConnectionString"</span><span class="p">);</span>
<span class="n">Simple</span><span class="p">.</span><span class="n">Data</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">OpenConnection</span><span class="p">(</span><span class="n">Program</span><span class="p">.</span><span class="n">ConnectionString</span><span class="p">);</span>
</code></pre></div>
<p>By using <code>Database.Open()</code> Simple.Data will look for a connection string called <code>Simple.Data.Properties.Settings.DefaultConnectionString</code> and use it to create the database instance.  Alternatively you can specify a specific named connection using <code>Database.OpenNamedConnection</code> or even a raw connection string using <code>Database.OpenConnection</code></p><p>These methods all return a special <code>dynamic</code> object that dynamically creates a <span class="caps">SQL</span> statement by constructing methods on the fly.  It's best to look at the code for this.  To select a single object we can do this,</p><div class="highlight"><pre><code><span class="n">Author</span> <span class="n">author</span> <span class="p">=</span> <span class="n">Simple</span><span class="p">.</span><span class="n">Data</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">Open</span><span class="p">().</span><span class="n">Author</span><span class="p">.</span><span class="n">FindById</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</code></pre></div>
<p>So whats happening here.  Well firstly we a asking it to look at the Authors table.  Next we are telling it to FindById - but this method doesn't exist. We could easily have said FindByUsernameAndEmail and we would get the results we expected.  This bit of metaprogramming is the magic behind Simple.Data where method signatures are parsed and used to build <span class="caps">SQL</span>.  Nice stuff.  I still have a bit of issue working with dynamic objects but in this case my models are concrete so it's really not an issue.</p><p>Selecting multiple objects is that same except instead of <code>FindByXXX</code> we use <code>FindAllByXXX</code> and as this query returns a <code>SimpleQuery</code> object we then need to perform a <code>.Cast&lt;Author&gt;</code> at the end to get back a list of authors.</p><p>An alternative and more flexible way of doing queries is using <code>Find</code> and <code>FindAll</code>.  These methods let you specify more complex queries.  To implement our <code>LIKE</code> comparison for our query above we need to use <code>FindAll</code> like so,</p><div class="highlight"><pre><code><span class="kt">dynamic</span> <span class="n">authors</span> <span class="p">=</span> <span class="n">Simple</span><span class="p">.</span><span class="n">Data</span><span class="p">.</span><span class="n">Database</span><span class="p">.</span><span class="n">Open</span><span class="p">().</span><span class="n">Authors</span><span class="p">;</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;</span> <span class="n">authors</span> <span class="p">=</span> <span class="n">authors</span>
    <span class="p">.</span><span class="n">FindAll</span><span class="p">(</span><span class="n">authors</span><span class="p">.</span><span class="n">Username</span><span class="p">.</span><span class="n">Like</span><span class="p">(</span><span class="s">"%.com"</span><span class="p">))</span>
    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;();</span>
</code></pre></div>
<p>This also shows the use of the <code>Cast&lt;T&gt;</code> mentioned above.  We can supply a variable number of arguments to <code>Find</code> and <code>FindAll</code> as well as using different comparison operators.</p><h2>That Was a Long One<sup class="footnote" id="fnr2"><a href="#fn2">2</a></sup></h2><p>So yeah not only have I touched on selecting single and multiple object at a high level I also had to add a bit of discussion around setting things up so I apologise for the length of this post.  On the plus side discussing configuration alone for MyBatis and nHibernate would probably take the same length of time.  Thats whats great about these microORMs 99% of the time you don't need all that set up for most projects.  No need getting bogged down in configuration when it's not actually achieving anything.</p><p>In terms of the syntax - so far I am quite taken by both Simple.Data and PetaPoco but that could change when I start really pushing things - after all everyone can do selects quite easily.</p><p>In terms of dynamic results (e.g. from Massive) I'm still to be convinced on their usefulness without having to always map to concrete classes.  I don't see how this helps refactoring (it looks like it makes it much worse) nor do I see how it works with most validation mechanisms.  But I would love to be proven wrong on this please.</p><p>One thing I do know - it's going to take a lot more justification for someone to use a heavyweight <span class="caps">ORM</span> in my next project.  While I not willing to declare the death of ORMs like some other people I am certainly leaning in that direction.</p><p>Source for this series is slowly evolving in a <a href="https://github.com/kouphax/microorm-comparison">Github repo</a> if you feel inspired to have a poke around.</p><p class="footnote" id="fn0"><a href="#fnr0"><sup>0</sup></a> We can argue about plural or singular data naming conventions some other time, or in the comments!!!</p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> I created a load of test data using the handy little tool <a href="http://autopoco.codeplex.com/">AutoPoco</a></p><p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> "Thats what she said" &lt;self:facepalm&gt;</p>