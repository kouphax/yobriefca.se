<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>ASP.NET | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/asp-net/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2012-03-19T22:15:41+00:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[< HEAD >ache: Including JavaScript in ASP.NET Master Pages]]></title>
    <link href="http://yobriefca.se/blog/2010/10/19/-head-ache-including-javascript-in-asp-net-master-pages/"/>
    <updated>2010-10-19T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2010/10/19/-head-ache-including-javascript-in-asp-net-master-pages</id>
    <content type="html"><![CDATA[<p>  <h2>Problem</h2><p>Include a Javascript file in the head of of an ASP.NET WebForms Master Page whose src attribute should contain an absolute (from Application Root) path e.g.http://localhost:8080/js/jquery-1.3.2.js&nbsp;(single application server) or <a href="http://localhost:8080/MyProject/js/jquery-1.3.2.js">http://localhost:8080/MyProject/js/jquery-1.3.2.js</a> (multi application server).&nbsp; Sounds simple enough but it&rsquo;s surprisingly difficult.</p><h3>Attempt 1: Use a fixed path. (Partial Success)</h3><p><script src="https://gist.github.com/634782.js"></script></p><p>While this &ldquo;works&rdquo; it isn&rsquo;t exactly the most resilient to server changes &ndash; what if we move to/from a single/multi application server?&nbsp; We need to re-write all our URL&rsquo;s</p><h3>Attempt 2: Use Application Root Reference (~) (Fail)</h3><p><script src="https://gist.github.com/634783.js"></script></p><p>This just plain doesn&rsquo;t work because script tags do not get parsed by ASP page renderer so the URL doesn&rsquo;t get converted and what you see here is what you end up with on the page which obviously isn&rsquo;t correct.</p><h3>Attempt 3: Use Server Code (&lt;%= %&gt;) (Partial Success/Fail)</h3><p><script src="https://gist.github.com/634784.js"></script></p><p>Again this is going to fail in certain situations (but not all).&nbsp; This will fail when your head tag has a runat=&rdquo;server&rdquo; attribute present.&nbsp; In some cases you can simply remove the attribute but if you are using the &ldquo;out-of-the-box&rdquo; CSS Themes/Skins you NEED this.</p><h3>Attempt 4: Use a Second &lt;HEAD&gt; Element (Partial Success)</h3><p><script src="https://gist.github.com/634785.js"></script></p><p>This will work as you would expect &ndash; the only problem is that it isn&rsquo;t valid Markup and will fail if you throw it through W3C Validators.</p><h3>Attempt 5: Add script tags &ldquo;Outside&rdquo; Head Element (Partial Success)</h3><p><script src="https://gist.github.com/634788.js"></script></p><p>Again this will work the only problem is you can never guarantee another developer won&rsquo;t stick code (which is dependant on your global script) BEFORE your inclusion of said script which is a bit of a &lt;head&gt;ache (i.e. in the &lt;head&gt; element &ndash; get it?).</p><h3>Attempt 6: Insert Script Tags via MasterPage Page_Load Event (Success)</h3><p><script src="https://gist.github.com/634790.js"></script></p><p>I suppose this is the first real successful attempt.&nbsp; It does what it says by dynamically creating new Script tag element and inserting them to the top of &lt;head&gt;.&nbsp; I inserted everything at the top of the head so no matter where people put their scripts it&rsquo;s going to have all global resources available.&nbsp; The only problem with this is that EVERY Page_Load event is going to dynamically inject new Elements into the head and it&rsquo;s not exactly a very clean separation of mark-up and code.</p><h3>Attempt 7/Solution 1: Use Data Binding to Evaluate src Attribute (AKA The Holmes Technique)</h3><p>ASPX</p><p><script src="https://gist.github.com/634791.js"></script></p><p>Jonny Holmes&nbsp;<a href="http://leedumond.com/blog/the-controls-collection-cannot-be-modified-because-the-control-contains-code-blocks/">uncovered</a>&nbsp;a more elegant solution to this issue and it is described above.&nbsp; It gets around the issue of not being able to use &lt;%= %&gt; tags by using a Data Binding Expression.&nbsp; And all you have to do is perform a DataBind() during the Page_Load event and you&rsquo;re sorted like&nbsp;<a href="http://www.youtube.com/watch?v=e0Mzr_A-Q0I">Ebenezer</a>.</p><p><script src="https://gist.github.com/634793.js"></script></p><p>Anyone got any other methods to do this?</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UpdatePanels & Alternatives]]></title>
    <link href="http://yobriefca.se/blog/2009/04/15/updatepanels-alternatives/"/>
    <updated>2009-04-15T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2009/04/15/updatepanels-alternatives</id>
    <content type="html"><![CDATA[<p>  <p><p>I&rsquo;m not sold on ASP.NET UpdatePanels. Conceptually they are quite nice but their implementation is nasty. So much so I&rsquo;d be happy to say the should be considered an anti-pattern. My reasons? Well&hellip;</p><ul><li>They generate too much JavaScript</li><li>It&rsquo;s too &ldquo;development focused&rdquo; &ndash; it puts saving time ahead of a clean performant solution</li><li>Ajax calls should be data focused (returning XML, JSON etc), UpdatePanels are content focused</li><li>Generates a massive amount of network traffic in comparison to alternative solutions (including ViewState and markup)</li><li>UpdatePanels use innerHTML to replace contents which orphans bound events (leakage) that need to be rebound each time (extra work).</li></ul><p>But what are the alternatives? Page Methods and Scripted Services are a good starting point. The good things about these alternatives is that they are lightweight &ndash; they send JSON data to and from the server so your network traffic is greatly reduced. Here is a simple example of using a page method &ndash; I&rsquo;ll not cover Scripted Services as they are very similar and you can find info about them on the net.</p><p>In your code behind you can add a [WebMethod] attributed method</p><div><span style="font-size: small;"><span><script src="https://gist.github.com/632988.js"></script></span></span></div><p>And turn on EnablePageMethods attribute of the pages ScriptManager</p><div><span style="font-size: small;"><span><script src="https://gist.github.com/632990.js"></script></span></span></div><p>What happens next is that when the page is rendered a JavaScript Proxy Class will be generated called PageMethods that contains a function call GetCurrentDateAndTime. It&rsquo;ll look something like this.</p><div><span style="font-size: small;"><span><script src="https://gist.github.com/632991.js"></script></span></span></div><p>Now all we have to do is use it. This is easy&hellip;</p><div><span style="font-size: small;"><span><script src="https://gist.github.com/632994.js"></script></span></span></div><p>That wasn&rsquo;t too difficult now was it? But we aren&rsquo;t done yet. Sure this solution works but there is still one problem &ndash; We are including the ScriptManager in our page which means event though all we are doing is getting a date back from the server we are still required to pull down at least 160k (in it&rsquo;s most compressed &amp; gzipped form) of framework 90% of which we aren&rsquo;t even going to use.</p><h3>Calling PageMethods and ScriptedServices using jQuery</h3><p>Obviously a request from client to server is always done through HTTP it doesn&rsquo;t actually matter how it is handled on the client. So it&rsquo;s easy to swap out the ASP.NET Ajax framework for jQuery. You&rsquo;ll probably be asking why? Well the long and short of it is that regardless of what the requirements say you (or someone else on the project) WILL end up writing Javascript and jQuery is the better choice&hellip;</p><ul><li>It&rsquo;s a better, smaller, compact and faster framework</li><li>It&rsquo;s much better documented and easier to learn</li><li>It&rsquo;s extensible via plugins so you don&rsquo;t need the whole &ldquo;kitchen sink&rdquo; to do simple things</li><li>It can do everything ASP.NET Ajax can do</li><li>It&rsquo;s technology agnostic so you can jump to a Java project and use the same solutions</li></ul><p>I could go on, honestly I could, but that&rsquo;s not what this post is about. There are a few nuances in calling PageMethods and ScriptedServices, namely</p><ul><li>The request content-type must be&nbsp;<code>application/json; charset=utf-8</code></li><li>The request must be a POST request</li><li>Data sent to the server must be encoded as a JSON string or &ldquo;{}&rdquo; if empty</li><li>Standard ASP.NET JSON serialization doesn&rsquo;t convert DateTime to a proper JSON date</li><li>The JSON data in the request must map directly to arguments of the function</li></ul><p>Failure to comply with any of the above will result in either a security error or, usually, the entire page being rendered back to the response. So calling the above PageMethod using jQuery is as simple as this&hellip;.</p><div><span style="font-size: small;"><span><script src="https://gist.github.com/632996.js"></script></span></span></div><p>Not bad, but there is a lot of boiler plate code there. Thankfully it&rsquo;s easy to write a jQuery plugin to abstract out most of this and make the calls simple.&nbsp;So all in all even with the 2 plugins (JSON and .Net Services) and the jQuery framework we are only forced to pull down 60k of scripts (minified but NOT gzipped) so you could see this reduced to 25-30k all in with gzipping turned on.</p></p></p>
]]></content>
  </entry>
  
</feed>
