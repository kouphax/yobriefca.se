<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>Miscellaneous | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/miscellaneous/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2013-01-21T12:00:38+00:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[yobriefcasts: Screencasts with a JVM flavour]]></title>
    <link href="http://yobriefca.se/blog/2013/01/21/yobriefcasts-screencasts-with-a-jvm-flavour/"/>
    <updated>2013-01-21T11:03:00+00:00</updated>
    <id>http://yobriefca.se/blog/2013/01/21/yobriefcasts-screencasts-with-a-jvm-flavour</id>
    <content type="html"><![CDATA[<p>Today sees the inaugural launch of a new project/passion of mine - <a href="http://yobriefcasts.tv">yobriefcasts.tv</a>.  There is a launch post about it on the <a href="http://yobriefcasts.tv">site</a> as well as the first in a series of screencasts around Play! 2 (more being edited as you read this no doubt).  Initially I never set out to focus on the world of the JVM but after building a list of potential topics and doing some research there is just so much there and so little audio/visual coverage of it that I think it deserves some attention.</p>

<p>As it stands right now there is an [optional] price associated with the productions - you can stream everything to your hearts content or you can pay a minimal sum to get a high quality download of the screencast - you can do both if you want.  It took a while to come to an acceptable price point and structure because I have an end goal here - I want to feed any money earned back into the project to get better equipment and thusly produce better quality screencasts.  Futhermore I'd eventually like to turn this into a (mostly) full time gig and move to a subscription model with frequent (weekly) releases - but thats a long way away yet - for now I want to see if I can build something people want and enjoy.</p>

<p>But hopefully the site can speak for itself - I've already got an extensive list of releases coming up over the next while so stay tuned, follow us on <a href="http://twitter.com/yobriefcasts">twitter as @yobriefcasts</a> and enjoy the <a href="http://yobriefcasts.tv">site</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vertical vs Horizontal Thinking]]></title>
    <link href="http://yobriefca.se/blog/2012/11/17/vertical-vs-horizontal-thinking/"/>
    <updated>2012-11-17T22:48:00+00:00</updated>
    <id>http://yobriefca.se/blog/2012/11/17/vertical-vs-horizontal-thinking</id>
    <content type="html"><![CDATA[<p>I'm not quite sure were this ramble is going to lead, it's been a while since I've felt like writing something that hasn't been clearly defined by my half conscious brain but lets take the journey anyway shall we?</p>

<p>This is going to be loosely related to agility, not necessarily the "agile method or process" but more simply about adapting to change and embracing transparency in a software project.  More often than not this can be simply referred to as "common sense" and it's a great thing.</p>

<p>But I digress,</p>

<p>In a vertical world you deliver features by implementing vertical spikes through each layer of the system architecture.  It doesn't have to be right, but it does need to be good enough for now.  Sure it may not deliver the best user experience or maybe there are more HTTP requests or database calls than necessary but it's useable.  Its shippable.</p>

<p>In the horizontal world layers of the architecture are tackled by (possibly pseudo) specialists and delivered en masse.  This is very typical of the Big Design Upfront, Plan Based, Waterfall approach to delivery but its visible in a lot of projects in various guises and it's rather natural to many people.</p>

<p>Now, on the surface, getting specialists to deliver what they know best and then smash them altogether actually sounds great.  You know your DB person is going to produce a wonderful hyper-normalised schema for you, your UI/UX person will deliver a gorgeous mockup of the site and your middle layer app people will deliver the best truly ReSTful service layer known to man.  But then you spend an insane amount of time (or many many little periods of time) doing the actual integration and making this vision a reality.  The testing, the regressions, the edge cases the performance hits and sacrifices through integrating perfect works of horizontal art.  Best case you get it done eventually, worst case someone else gets it done by layering hack upon hack at integration points just to get it working.</p>

<p>Now imagine your DB person gets eaten by a badger, or your UI person decides they've had enough and goes to live in a free-love commune and drink the spiked kool-aid?  I've overly dramatised the <a href="http://en.wikipedia.org/wiki/Bus_factor">Bus Factor</a> here but the point is still made.  You've lost siloed knowledge forever and you need to spend time building it up again, and time and quality slip.</p>

<p>Finally - projects that deliver horizontally are, more often than not, projects that have limited customer/stakeholder visibility.  Sometimes even less for end-users.  So delivering a mockup of the UI and a DB schema that can be exported as a nice UML diagram is enough to satisfy people that work is on-going and going well.  Even if it isn't.  It's not a lie but it is a false impression, and it's an impression that doesn't work for long especially if you have shorter release cycles with ongoing customer interaction.  A page of beautiful buttons that don't do anything will create an impression that you are nearly done and can easily generate disappointment at subsequent demos.  Is it worth it?</p>

<p>Don't get me wrong it is very possible to successfully deliver software in this manner, on time and on budget but so many things must fall into place and all the stars must be aligned that it's a rather big risk, but a risk that people seem to ignore.</p>

<p>So I'm saying vertical is better and there are many reasons for that and I'll touch on some of them here but there is one very fundamental reason it's better.  Working and thinking vertically allows you to create a shippable product early.  It's not all done, far from it.  It probably looks like ass as well but still it's usable enough to get the job done, right?  Imagine using a new product that looked amazing but only had 3 working features and the rest of the buttons and knobs didn't do anything.  Wow factor is for kids and sales men.</p>

<p>Why else is vertical thinking better?</p>

<p>For one everyone on the team works across all layers of the solution.  You don't have huge silos of knowledge contained in a single brain of some crazy bus magnet.  Sure you may involve specialists to ensure you're not doing it totally wrong but at least you'd be working WITH them and picking up parts of the vast knowledge they may have.</p>

<p>By delivering something "good enough for now" you actually reduce waste.  True you may re-write a few things to get it right but you haven't spent hours crafting perfection only to tear it apart.  Even better the first iteration may make users realise - "Actually you know what?  That super whizzy button thing - we don't need it".  Waterfall attempts to "manage change" because change in waterfall is scary expensive.  Embrace it early and often and it much less costly.</p>

<p>Finally, the solution evolves rather than being dragged into existence from a 189 page document of business rules and textual assumptions.  This allows you to experiment and try things, throw them away or discover a better way of doing things.  You can adapt the solution at anytime to suit the changing nature of the environment it lives in.</p>

<p>Vertical thinking is a proven pattern in many other aspects of the software world.  TDD for example. Rather than writing reams of code and testing it manually later, you create a solution bit by bit and adapt it fearlessly as you go.  UI designers never just bang out one design and leave it there.  Smaller feedback loops are essential to flow and success and vertical thinking gives you this.  Break the habit of wowing people and replace it with the habit of delivering - it's a better, longer lasting feeling of win.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Technology Techsmology]]></title>
    <link href="http://yobriefca.se/blog/2012/11/05/technology-techsmology/"/>
    <updated>2012-11-05T08:48:00+00:00</updated>
    <id>http://yobriefca.se/blog/2012/11/05/technology-techsmology</id>
    <content type="html"><![CDATA[<p>There is an old adage,</p>

<blockquote><p>Projects don't fail because of technology decisions</p></blockquote>

<p>The younger me would have got all uppity and defensive when he heard this statement.  As a developer/architect type whose main goal is to make key technology decisions on a project (not to mention as a person who likes to grandiously consider themselves a craftsman) this does seem rather belittling.  Are you telling me all my decisions are fairly irrelevant?  I'll just stay in bed then shall I?</p>

<p>But you know what?  The statement is also completely true.</p>

<p>But hey, wait - do you want to know something else? Yes? Good.</p>

<p>The world of technology is not black and white, projects aren't either a success or a failure, it's simply not a binary system.  Projects may not fail, but they could be late.  They could be well over budget.  They could have code bases so toxic that you need to hire contractors to do the work because no one wants to touch it.  They could be so overly laden in patterns and complex architecture that even small changes take weeks or months to implement (and who foots the bill for that?).</p>

<p>Technology decisions can indirectly ruin the morale of your staff, muddy the relationship with your customers and generate really high turnover of staff in your company (which may be a good fit for some companies but you can never foster excellence if you don't nurture talent).</p>

<p>This statement can also be used as a weapon - a weapon to excuse bad decisions and hold back change (both good and bad, in short it stiffles learning).  People cling to technologies that they used in the past, for fear of more pain with other technologies.  They shoehorn their existing skillset into problem domains that aren't a good fit.  When this happens, at the extreme you end up with specialists that simply can't adapt to shifts in technology fast enough.</p>

<p>So yeah, projects don't fail because of technology decisions.  But you know what - if your dentist turned round to you with an evil grin and a rusty chisel and <a href="http://en.wikipedia.org/wiki/Law_of_the_instrument">Maslow's Hammer</a> citing - "No surgery ever went wrong because of a lack of anesthetic" - you're not likely to get in to that chair and open wide.  And even if you did (maybe, you're drunk, maybe people keep telling you this dentist is the best, whatever) the experience would be painful, recovery time would be longer and subsequent treatments would probably be more painful.  A rather shambling metaphor I admit but I write what my brain dictates - I have not choice in the matter.</p>

<p>Finally, I fully accept that many of these decisions are out of our control.  Customers, especially big ones, generally have the final say, they've potentially invested a lot of time on a certain stack and have a lot of legacy (read: code that still works) solutions in play.  True, but one of our goals is to at least inform these people of the alternatives and let them make an informed decision - maybe not today but soon enough the cost of developing and maintaining new systems built on out-of-support JDKs will come under scrutiny and they'll need to consider alternatives, alternatives that you've already enlightened them about.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fear of Code]]></title>
    <link href="http://yobriefca.se/blog/2012/08/05/fear-of-code/"/>
    <updated>2012-08-05T20:36:00+01:00</updated>
    <id>http://yobriefca.se/blog/2012/08/05/fear-of-code</id>
    <content type="html"><![CDATA[<p>More silly wishy washy nonsense - take what you will.</p>

<p>Recently Thomas Fuchs has this to say on twitter,</p>

<blockquote class="twitter-tweet"><p>As a programmer, you should be afraid of code, and eliminate as much as possible.</p>&mdash; Thomas Fuchs (@thomasfuchs) <a href="https://twitter.com/thomasfuchs/status/230871987881390081" data-datetime="2012-08-02T03:45:45+00:00">August 2, 2012</a></blockquote>


<script src="http://yobriefca.se//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Its great, I love this stuff and it got me thinking and I thought why not put my thoughts up here, right?  After all this is what this place is all about.</p>

<p>Rather than describe the emotion as fear ("be afraid of code") i'd posit that, as a programmer, you should be respectful of code.  Rather than eliminate as much as possible you should conserve it as much as possible - don't write it in the first place.</p>

<p>A while back I posted something similar on Twitter - I can't find the tweet right now but it went a little something like this,</p>

<blockquote><p>Adding code is great, removing code is greater but not writing the code in the first place is greatest</p></blockquote>

<p>As a developer it is very easy to fall into the trap of creating some sort of highly reusable complex masterpiece that is going to change the way we write code forever.  But down that road, madness lies.  Desigining too much, adding too many features, creating too many abstractions, handling every single edge case, writing too many tests - all this stuff is just extra complexity, extra code that simply muddies the solution and makes it harder for someone to understand the solution.  More code doesn't solve the problem faster, more code doesn't make things easier, more code doesn't help.</p>

<p>In other words - writing too much code, regardless of quality is just a selfish act.  That goes for 3rd party code too.</p>

<p>Quit it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin: Here's What I Think (For Now)]]></title>
    <link href="http://yobriefca.se/blog/2012/07/15/kotlin-heres-what-i-think/"/>
    <updated>2012-07-15T16:43:00+01:00</updated>
    <id>http://yobriefca.se/blog/2012/07/15/kotlin-heres-what-i-think</id>
    <content type="html"><![CDATA[<blockquote><p>Before I go shooting my mouth off here - a word of warning - I haven't really done anything with Kotlin.  I've read the docs, played with the <a href="https://github.com/dodyg/Kotlin101">Kotlin 101 samples</a> and written a few small console type apps.  So take what you want from this post.</p></blockquote>

<p>Want to hear something zany?  There actually are people - real living people, with a fully working brain, many much smarter than me - that are "happy" with Java.</p>

<p>Seriously.</p>

<p>I made a move from Java to .NET about 5 years ago and have dipped back in a few times over that period.  Trying new languages is a sure fire way, for some at least, to make you realise Java is not a language that makes coding fun, or productive.  Java put me right of the JVM.  Any language that makes woking with collections (something you'll do alot) so long winded and noisy deserves to be shunned.  But this isn't a Java rant - the JVM is great but it's just marketed badly because of Java.</p>

<p>But all the JVM-hate that Java instilled in me 5 years ago; the last 6 months of working with Scala has replaced with love.  So I've been looking around the JVM world and discovered <a href="http://kotlin.jetbrains.org/">Kotlin</a> a new JVM based language from JetBrains.  Its much closer to Java than what Scala or Clojure is (intentionally).</p>

<p>One main thing that Kotlin brings to the table is pragmatism.  Without trying to belittle Kotlin - it's almost like CoffeeScript for Java (yep kind of like what <a href="http://www.eclipse.org/xtend/">Xtend</a> is.  Kotlin removes all those annoying necessities in Java that make your code verbose (checked exceptions, semi-colons, null reference checks etc.).  It also adds things that make your life much easier (extension methods, functional collection manipulation etc.).</p>

<p>When you write Ruby for the first time you notice that many things just work out like you'd expect, the syntax is quite natural.  The same cannot be said for Java - there is just way too much boilerplate.  Kotlin helps reduce that boilerplate.  So, by extension, it could be said that Kotlin makes you more productive.  A person who knows Java will find Kotlin no challenge to start using - the syntax is nicely aligned, just without the noise.</p>

<p>Many people, when trying to get their team to adopt Scala, use the "you can use Scala like Java til you get used to it" mantra.  I don't agree with that.  Academically it's true but the minute you start working with other peoples Scala code - you've just gotta know Scala and when they have a slew of Implicits thrown in your Scala as Java stuff goes out the window.  Kotlin, on the other hand, has some of the nice functional patterns from Scala but none of the "magic-to-a-newcomer" features that can make grown men weep.  Now the Kotlin docs themselves even go as far as stating</p>

<blockquote><p>  If you are happy with Scala, you probably don't need Kotlin.</p></blockquote>

<p>But I think they are selling themselves short - I think plenty of people use Scala but could easily use Kotlin in its place and find themselves in a better place (easier upskilling, less cryptic codebase).</p>

<p>Anyway this is a bit of a ramble, what I'm saying is - Kotlin has some really rather nice features (Groovy Like DSL Builders, Pattern Matching, the <code>when</code> expression, lambdas, Kotlin to JavaScript compilation(!) etc.) and people happy with either Java OR Scala should give it a go.</p>
]]></content>
  </entry>
  
</feed>
