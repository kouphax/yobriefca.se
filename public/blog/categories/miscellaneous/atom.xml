<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>Miscellaneous | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/miscellaneous/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2012-11-05T08:53:00+00:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Technology Techsmology]]></title>
    <link href="http://yobriefca.se/blog/2012/11/05/technology-techsmology/"/>
    <updated>2012-11-05T08:48:00+00:00</updated>
    <id>http://yobriefca.se/blog/2012/11/05/technology-techsmology</id>
    <content type="html"><![CDATA[<p>There is an old adage,</p>

<blockquote><p>Projects don't fail because of technology decisions</p></blockquote>

<p>The younger me would have got defensive when they heard this statement.  As a developer/architect type whose main goal is to make key technology decisions on a project and also as a person who considers themselves a craftsman (yes, yes overly grandiose but still, we all dream of importance) this does seem rather belittling.  Are you telling me all my decisions are fairly irrelevant?  I'll just stay in bed then shall I?</p>

<p>But you know what?  The statement is also completely true.</p>

<p>But hey, wait - do you want to know something else? Yes? Good.</p>

<p>The world of technology is not black and white, projects aren't either a success or a failure, it's simply not a binary system.  Projects may not fail, but they could be late.  They could be well over budget.  They could have code bases so toxic that you need to hire contractors to do the work because no one wants to touch it.  They could be so overly laden in patterns and complex architecture that even small changes take weeks or months to implement (and who foots the bill for that?).</p>

<p>Technology decisions can indirectly ruin the morale of your staff, muddy the relationship with your customers and generate really high turnover of staff in your company (which may be a good fit for some companies but you can never foster excellence if you don't nurture talent).</p>

<p>This statement can also be used as a weapon.  A weapon to mask bad decisions and hold back change.  People cling to technologies that they used in the past, for fear of more pain with other technologies.  They shoehorn their existing skillset into problem domains that aren't a good fit.  When this happens, at the extreme you end up with specialists that simply can't adapt to shifts in technology fast enough.</p>

<p>So yeah, projects don't fail because of technology decisions.  But you know what - if your dentist turned round to you with an evil grin and a rusty chisel and <a href="http://en.wikipedia.org/wiki/Law_of_the_instrument">Maslow's Hammer</a> citing - "No surgery ever went wrong because of a lack of anesthetic" - you're not likely to get in to that chair and open wide.  And even if you did (maybe, you're drunk, maybe people keep telling you this dentist is the best, whatever) the experience would be painful, recovery time would be longer and subsequent treatments would probably be more painful.  A rather shambling metaphor I admit but I write what my brain dictates - I have not choice in the matter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fear of Code]]></title>
    <link href="http://yobriefca.se/blog/2012/08/05/fear-of-code/"/>
    <updated>2012-08-05T20:36:00+01:00</updated>
    <id>http://yobriefca.se/blog/2012/08/05/fear-of-code</id>
    <content type="html"><![CDATA[<p>More silly wishy washy nonsense - take what you will.</p>

<p>Recently Thomas Fuchs has this to say on twitter,</p>

<blockquote class="twitter-tweet"><p>As a programmer, you should be afraid of code, and eliminate as much as possible.</p>&mdash; Thomas Fuchs (@thomasfuchs) <a href="https://twitter.com/thomasfuchs/status/230871987881390081" data-datetime="2012-08-02T03:45:45+00:00">August 2, 2012</a></blockquote>


<script src="http://yobriefca.se//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Its great, I love this stuff and it got me thinking and I thought why not put my thoughts up here, right?  After all this is what this place is all about.</p>

<p>Rather than describe the emotion as fear ("be afraid of code") i'd posit that, as a programmer, you should be respectful of code.  Rather than eliminate as much as possible you should conserve it as much as possible - don't write it in the first place.</p>

<p>A while back I posted something similar on Twitter - I can't find the tweet right now but it went a little something like this,</p>

<blockquote><p>Adding code is great, removing code is greater but not writing the code in the first place is greatest</p></blockquote>

<p>As a developer it is very easy to fall into the trap of creating some sort of highly reusable complex masterpiece that is going to change the way we write code forever.  But down that road, madness lies.  Desigining too much, adding too many features, creating too many abstractions, handling every single edge case, writing too many tests - all this stuff is just extra complexity, extra code that simply muddies the solution and makes it harder for someone to understand the solution.  More code doesn't solve the problem faster, more code doesn't make things easier, more code doesn't help.</p>

<p>In other words - writing too much code, regardless of quality is just a selfish act.  That goes for 3rd party code too.</p>

<p>Quit it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin: Here's What I Think (For Now)]]></title>
    <link href="http://yobriefca.se/blog/2012/07/15/kotlin-heres-what-i-think/"/>
    <updated>2012-07-15T16:43:00+01:00</updated>
    <id>http://yobriefca.se/blog/2012/07/15/kotlin-heres-what-i-think</id>
    <content type="html"><![CDATA[<blockquote><p>Before I go shooting my mouth off here - a word of warning - I haven't really done anything with Kotlin.  I've read the docs, played with the <a href="https://github.com/dodyg/Kotlin101">Kotlin 101 samples</a> and written a few small console type apps.  So take what you want from this post.</p></blockquote>

<p>Want to hear something zany?  There actually are people - real living people, with a fully working brain, many much smarter than me - that are "happy" with Java.</p>

<p>Seriously.</p>

<p>I made a move from Java to .NET about 5 years ago and have dipped back in a few times over that period.  Trying new languages is a sure fire way, for some at least, to make you realise Java is not a language that makes coding fun, or productive.  Java put me right of the JVM.  Any language that makes woking with collections (something you'll do alot) so long winded and noisy deserves to be shunned.  But this isn't a Java rant - the JVM is great but it's just marketed badly because of Java.</p>

<p>But all the JVM-hate that Java instilled in me 5 years ago; the last 6 months of working with Scala has replaced with love.  So I've been looking around the JVM world and discovered <a href="http://kotlin.jetbrains.org/">Kotlin</a> a new JVM based language from JetBrains.  Its much closer to Java than what Scala or Clojure is (intentionally).</p>

<p>One main thing that Kotlin brings to the table is pragmatism.  Without trying to belittle Kotlin - it's almost like CoffeeScript for Java (yep kind of like what <a href="http://www.eclipse.org/xtend/">Xtend</a> is.  Kotlin removes all those annoying necessities in Java that make your code verbose (checked exceptions, semi-colons, null reference checks etc.).  It also adds things that make your life much easier (extension methods, functional collection manipulation etc.).</p>

<p>When you write Ruby for the first time you notice that many things just work out like you'd expect, the syntax is quite natural.  The same cannot be said for Java - there is just way too much boilerplate.  Kotlin helps reduce that boilerplate.  So, by extension, it could be said that Kotlin makes you more productive.  A person who knows Java will find Kotlin no challenge to start using - the syntax is nicely aligned, just without the noise.</p>

<p>Many people, when trying to get their team to adopt Scala, use the "you can use Scala like Java til you get used to it" mantra.  I don't agree with that.  Academically it's true but the minute you start working with other peoples Scala code - you've just gotta know Scala and when they have a slew of Implicits thrown in your Scala as Java stuff goes out the window.  Kotlin, on the other hand, has some of the nice functional patterns from Scala but none of the "magic-to-a-newcomer" features that can make grown men weep.  Now the Kotlin docs themselves even go as far as stating</p>

<blockquote><p>  If you are happy with Scala, you probably don't need Kotlin.</p></blockquote>

<p>But I think they are selling themselves short - I think plenty of people use Scala but could easily use Kotlin in its place and find themselves in a better place (easier upskilling, less cryptic codebase).</p>

<p>Anyway this is a bit of a ramble, what I'm saying is - Kotlin has some really rather nice features (Groovy Like DSL Builders, Pattern Matching, the <code>when</code> expression, lambdas, Kotlin to JavaScript compilation(!) etc.) and people happy with either Java OR Scala should give it a go.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Technology in the Cloud]]></title>
    <link href="http://yobriefca.se/blog/2012/07/12/technology-in-the-cloud/"/>
    <updated>2012-07-12T13:59:00+01:00</updated>
    <id>http://yobriefca.se/blog/2012/07/12/technology-in-the-cloud</id>
    <content type="html"><![CDATA[<p>The Cloud.  As much as the term has been pummelled into meaningless marketing sputum by the guys in expensive suits and fake smiles it does exist and is distinct from a typical "throw all your stuff in a data center" setup.</p>

<p>The Cloud is distinct, as well, in terms of how you think about your solution architecture.  The typical old school approach would be to just create big monoliths to process your data but that doesn't work out so well in the cloud.  Of course the considerations for the cloud aren't new, hell no - things like SOA have been around for an age, but if you want to harness the benefits of the cloud as the internet intended you will be narrowing your options.  No more just cobbling common bits together and crossing your fingers.</p>

<p>So fine - architecting for the cloud has some special considerations but thats not what I want to talk about - there are better people than me to cover that.</p>

<p>What I want to talk about is use of technology within that architecture.  I've never been a fan of the one-size-fits-all-painful-or-not technology stack driven almost solely by a need to avoid unnecessary education of developers.  And, now I feel the cloud is strengthening my view that a default stack is more trouble than it's worth.  More importantly it's really adding momentum to the whole polyglot architecture, or simply using the right tools for the job.</p>

<p>Let me explain.  Any default stack, by definition, needs to cater to many user cases and as such brings a certain amount of sacrifice with it.  Sacrifices come in many forms but usually in performance, memory footprint and/or verbose configuration.  In the cloud you are, in essence, in a Pay-As-You-Go model, every clock cycle and every bit of storage costs.  Now that heavy ORM with its less than ideal queries and slow relationship mapping is starting to cost you money EVERY request.  {% pullquote %} In fact, it's probably backed by that storage heavy relational database for all your non-relational data.  Same for that rather large web framework you've got there.... every time to deal with a spike and scale that badboy out and you're having to use medium instances rather than small.  That SOAP based webservice that requires triple the bandwidth to service a request... ugh you get the point. {" "In the cloud the default stack can easily bleed money." "}
{% endpullquote %}</p>

<p>I guess this is less about the default stack and more about just using the right tools to get the job done in the most effective manner - afterall you're paying for this stuff now.  You kind of were before but in such a coarse grained manner it didn't matter - it does now.</p>

<p>In summary - the cloud has started to make technology decisions more accountable and we need to ensure that those decisions aren't costing our stakeholders more money than necessary.</p>

<p>PS.</p>

<p>I'm not going to sit here and preach about the which specific technologies to use but come on - if your storing Session State in a Oracle database, switch to Riak, or Redis.  If you're building a nice scalable API then use something like Scala which promotes immutable state and concurrency out of the box over something like vanilla Java (or perhaps just a better framework Spring-WS vs Dropwizard for example).  JSON over XML or a binary format (Protobuf for example) for machine to machine communication.  A small node.js web site over ASP.NET Webforms for simple sites.  The list goes on.  That is to say consider this advice against the other factors driving technical decisions - dont JUST go for the smallest, lightest tools because it MIGHT be cheaper.  Do the research.</p>

<p>Finally, perhaps you've got another IT team needing to support this new solution?  Bring them along this journey too, educate them as you educate yourself, dont just throw the finished thing over the wall with a 1 week handover and a pat on the back.</p>

<p>Don't be afraid - it's a super fun world we live in!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quitsies, Well Sort Of]]></title>
    <link href="http://yobriefca.se/blog/2012/07/03/quitsies/"/>
    <updated>2012-07-03T19:08:00+01:00</updated>
    <id>http://yobriefca.se/blog/2012/07/03/quitsies</id>
    <content type="html"><![CDATA[<blockquote><p>You know when you start to question why you write these things it's probably time to quit, or at least take a break.</p>

<p> ~ me, just there now</p></blockquote>

<p>This more of an FYI to anyone who may read this blog than a horrible diatribe about how I am wasting my life with meaningless exercises or technologies I'll never get to use to a bunch of people that don't really care, what would be the point?  Plus - it's probably not even true.</p>

<p>So rather than pottering on about cool and interesting technologies that will make everyones (read, developers) life infinitely better 100% guaranteed I've decided to devote my time to,</p>

<ol>
<li>Working on some startup-py type things that have been milling around the back of my head for some time, and,</li>
<li>Generally getting stuff done</li>
</ol>


<p>Yep, like a hipster band, this little testament to bike-shedding is going on indefinite hiatus.</p>
]]></content>
  </entry>
  
</feed>
