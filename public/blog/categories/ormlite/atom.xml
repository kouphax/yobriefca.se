<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>ORMLite | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/ormlite/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2012-12-28T20:10:10+00:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MicroORMs for .NET: Inserts, Updates &amp; Delete]]></title>
    <link href="http://yobriefca.se/blog/2011/06/21/microorms-for-dotnet-inserts-updates-deletes/"/>
    <updated>2011-06-21T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/06/21/microorms-for-dotnet-inserts-updates-deletes</id>
    <content type="html"><![CDATA[<p>  <blockquote class="announce">This post is the is part of series of posts covering the various microORMs in the .<span class="caps">NET</span> world.  I intend to look at how each microORM meets certain data access and manipulation needs.  The current series includes,<ul>   <li><a href="http://yobriefca.se/blog/2011/06/15/microorms-for-dotnet">Obligatory Introduction Post</a></li>    <li><a href="http://yobriefca.se/blog/2011/06/16/microorms-for-dotnet-select-one">Syntax &#8211; SELECTs</a></li>   <li><a href="http://yobriefca.se/blog/2011/06/18/microorms-for-dotnet-stored-procedures">Stored Procedures</a></li> <li><a href="http://yobriefca.se/blog/2011/06/21/microorms-for-dotnet-inserts-updates-deletes">Inserts, Updates &amp; Deletes</a><br></li></ul></blockquote><p>Moving swiftly on, if all our solutions only used different way to select data then how would we ever get data into our solution?  So lets look at how these microORMs handle Inserts, Updates and Deletes<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>.  These examples will follow on from previous ones so I am only going publish the key lines.  If you want the complete code you can grab them from the <a href="https://github.com/kouphax/microorm-comparison">GitHub project</a>.</p><h2>Dapper</h2><h3>Insert</h3><p>Nothing unexpected here.  More <span class="caps">SQL</span>.  Sam Saffron previously pointed me in the direction of <a href="http://code.google.com/p/dapper-dot-net/source/browse/Dapper.Contrib/Extensions/SqlMapperExtensions.cs">Dapper.Contrib</a> that has extra extension methods for doing things like <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> but at the time of trying I couldn&#8217;t get it to work and have an <a href="https://github.com/SamSaffron/dapper-dot-net/issues/8">open issue</a> on GitHub.  If I get an update on this I&#8217;ll post the slightly cleaner syntax.</p><p class="minimal-gist"><script src='https://gist.github.com/1036689.js?file=DapperInsert.cs'></script><noscript><pre><code>conn.Open();int count = conn.Execute(    "INSERT Authors(Username, FullName, CreatedDate) " +    "VALUES (@Username, @FullName, GETDATE())",    new { Username = "james@dapper.net", FullName = "James Hughes" });</code></pre></noscript></p><h3>Update</h3><p>Update is very similar to insert.  The nice thing about this approach vs. using POCOs is that you only need to send the delta of the object up where as with the other approaches you may have to fetch the object before updating.</p><p class="minimal-gist"><script src='https://gist.github.com/1037727.js?file=DapperUpdate.cs'></script><noscript><pre><code>int count = conn.Execute(    "UPDATE Authors SET FullName = @FullName WHERE Id = @Id",    new { FullName = "James Hughes", Id = 1 });</code></pre></noscript></p><h3>Delete</h3><p>Delete is pretty much what you&#8217;d expect.  I&#8217;ll update these examples when I get my problems with Dapper.Contrib sorted but when you are so close to the <span class="caps">SQL</span> metal there isn&#8217;t a massive amount to discuss.</p><p class="minimal-gist"><script src='https://gist.github.com/1037737.js?file=DapprDelete.cs'></script><noscript><pre><code>int count = conn.Execute(    "DELETE FROM Authors WHERE Id = @Id",    new { Id = 1 });</code></pre></noscript></p><h2>Massive</h2><h3>Insert</h3><p>Massive keeps things simple as usual.  <code>Insert</code> can take POCOs as well as dynamic object (and a number of other types) and it uses the info found in the <code>Authors</code> DynamicModel class to generate the <span class="caps">SQL</span> for you.</p><p class="minimal-gist"><script src='https://gist.github.com/1036724.js?file=MassiveInsert.cs'></script><noscript><pre><code>var tbl = new Authors();var x = tbl.Insert(new {    Username = "james@dapper.net",    FullName = "James Hughes",    CreatedDate = DateTime.Now});</code></pre></noscript></p><p>As a bonus feature Massive can wrap multiple inserts in a single transaction and perform multiple inserts at once.</p><p class="minimal-gist"><script src='https://gist.github.com/1037434.js?file=MassiveInsertMany.cs'></script><noscript><pre><code>var tbl = new Authors();var x = tbl.InsertMany( new [] {    { Username = "james@dapper.net", FullName = "James Hughes", CreatedDate = DateTime.Now },     { Username = "james@dapper.net", FullName = "James Hughes", CreatedDate = DateTime.Now },     { Username = "james@dapper.net", FullName = "James Hughes", CreatedDate = DateTime.Now } });</code></pre></noscript></p><h3>Update</h3><p>Like Dapper, Massive allows us to send only a delta between the old and new object.</p><p class="minimal-gist"><script src='https://gist.github.com/1037745.js?file=MassvieUpdate.cs'></script><noscript><pre><code>var tbl = new Authors();var x = tbl.Update(new {    FullName = "James Hughes"}, 1);</code></pre></noscript></p><p>Massive also gets extra points for the <code>UpdateMany</code> that, not suprisingly, behaves like the <code>InsertMany</code> method mentioned above (except for updates of course).</p><h3>Delete</h3><p>Ultra simple approach to Deleting specific objects just pass in an id and you&#8217;re done,</p><p class="minimal-gist"><script src='https://gist.github.com/1037749.js?file=MassiveDelete.cs'></script><noscript><pre><code>var tbl = new Authors();var x = tbl.Delete(2);</code></pre></noscript></p><h2>PetaPoco</h2><h3>Insert</h3><p>PetaPoco offers 2 main ways to insert your data<sup class="footnote" id="fnr2"><a href="#fn2">2</a></sup>.  You can pass in a plain <span class="caps">POCO</span> (or in our case on that uses attributes to normalise the difference between the schema and the C# class),</p><p class="minimal-gist"><script src='https://gist.github.com/1037467.js?file=PetaPocoInsert1.cs'></script><noscript><pre><code>PetaPoco.Database db = new PetaPoco.Database("DefaultConnectionString");var x = db.Insert(new Author{    Username = "james@dapper.net",    FullName = "James Hughes",    CreatedDate = DateTime.Now});</code></pre></noscript></p><p>Or you can pass in an anonymous object specifying the table and primary key field,</p><p class="minimal-gist"><script src='https://gist.github.com/1037469.js?file=PetaPocoInsert2.cs'></script><noscript><pre><code>var x = db.Insert("Authors", "Id", new{    Username = "james@dapper.net",    FullName = "James Hughes",    CreatedDate = DateTime.Now});</code></pre></noscript></p><h3>Update</h3><p>There are plenty of ways to update data using PetaPoco.  The first one is to pass in your model object and the row will get updated.  I am creating a new object in this example but you could just fetch it from the database as you&#8217;d expect,</p><p class="minimal-gist"><script src='https://gist.github.com/1037781.js?file=PetaPocoUpdate1.cs'></script><noscript><pre><code>PetaPoco.Database db = new PetaPoco.Database("DefaultConnectionString");var x = db.Update(new Author{    Id = 9,    Username = "james@dapper.net",    FullName = "James Hughes",    CreatedDate = DateTime.Now});</code></pre></noscript></p><p>Another approach is to just pass up a delta of the changes,</p><p class="minimal-gist"><script src='https://gist.github.com/1037784.js?file=PetaPocoUpdate2.cs'></script><noscript><pre><code>var x = db.Update("Authors", "Id", new{    Id = 10,    FullName = "James Hughes"});</code></pre></noscript></p><p>Alternatively you can simply pass up the delta and specify the primary key value externally,</p><p class="minimal-gist"><script src='https://gist.github.com/1037789.js?file=PetaPocoUpdate3.cs'></script><noscript><pre><code>db.Update("Authors", "Id", new { FullName = "James Hughes" }, 12);</code></pre></noscript></p><p>Variety is the spice of life in PetaPoco!</p><h3>Delete</h3><p>Thanks to the custom attribute on our Author class deleting a record is a matter of passing the Id to the <code>Delete</code> method,</p><p class="minimal-gist"><script src='https://gist.github.com/1037792.js?file=PetaPocoDelete.cs'></script><noscript><pre><code>db.Delete&lt;Author&gt;(8);</code></pre></noscript></p><h2>ServiceStack ORMLite</h2><h3>Insert</h3><p>ORMLite is pretty much inline with the other microORMs a simple <code>Insert</code> method that accepts a <span class="caps">POCO</span> or an anonymous object and generates <span class="caps">SQL</span> based on the info given.  This can be done in one of two ways,</p><p class="minimal-gist"><script src='https://gist.github.com/1037549.js?file=ORMLiteInsert1.cs'></script><noscript><pre><code>using (IDbConnection db = Program.ConnectionString.OpenDbConnection())using (IDbCommand cmd = db.CreateCommand()){    cmd.Insert&lt;Author&gt;(new Author    {        Username = "james@dapper.net",        FullName = "James Hughes",        CreatedDate = DateTime.Now    });}</code></pre></noscript></p><p>Or the factory approach discussed in the first article,</p><p class="minimal-gist"><script src='https://gist.github.com/1037551.js?file=ORMLiteInsert2.cs'></script><noscript><pre><code>IDbConnectionFactory dbFactory = new OrmLiteConnectionFactory(    Program.ConnectionString,    SqlServerOrmLiteDialectProvider.Instance);<p><p>dbFactory.Exec(dbCmd =&gt; dbCmd.Insert<author>(new Author<br>{<br>    Username = &#8220;james@dapper.net&#8221;,<br>    FullName = &#8220;James Hughes&#8221;,<br>    CreatedDate = DateTime.Now<br>}));</author></code></pre></noscript></p><h3>Update</h3><p>ORMLite sticks with one approach for updating a row &#8211; passing in a <span class="caps">POCO</span> that it can map to a table/row,</p><p class="minimal-gist"><script src='https://gist.github.com/1037796.js?file=ORMLiteUpdate.cs'></script><noscript><pre><code>cmd.Update(new Author{    Id = 7,    Username = "james@dapper.net",    FullName = "James Hughes",    CreatedDate = DateTime.Now});</code></pre></noscript></p><p>If you really don&#8217;t want to fetch your row again and only want to send up a delta you&#8217;ll have to roll your own approach (simple enough though).</p><h3>Delete</h3><p>ORMLite supports a number of neat ways to delete rows,</p><ul>   <li><code>DeleteById(id)</code></li>    <li><code>Delete(where_clause, id)</code></li>  <li><code>Delete(object)</code></li></ul><p class="minimal-gist"><script src='https://gist.github.com/1037807.js?file=ORMLiteDelete.cs'></script><noscript><pre><code>cmd.DeleteById&lt;Author&gt;(5);cmd.Delete&lt;Author&gt;("Id = @0", 6);cmd.Delete(new Author { Id = 7 });</code></pre></noscript></p><h2>Simple.Data</h2><h3>Insert</h3><p>Guess what Simple.Data&#8217;s approach is once again very fluent, clean and easy to understand.  OK I don&#8217;t get Intellisense as the methods are dynamic but I didn&#8217;t need it anyway.</p><p class="minimal-gist"><script src='https://gist.github.com/1037553.js?file=SimpleDataInsert.cs'></script><noscript><pre><code>Author x =  Simple.Data.Database.Open().Author.Insert(new Author{    Username = "james@dapper.net",    FullName = "James Hughes",    CreatedDate = DateTime.Now});</code></pre></noscript></p><h3>Update</h3><p>Simple.Data has 2 ways of updating.  <code>Update</code> takes a <span class="caps">POCO</span> and maps the id to the specific row,</p><p class="minimal-gist"><script src='https://gist.github.com/1037803.js?file=SimpleDataUpdate1.cs'></script><noscript><pre><code>Simple.Data.Database.Open().Authors.Update(new Author{    Id = 5,    Username = "james@dapper.net",    FullName = "James Hughes",    CreatedDate = DateTime.Now});</code></pre></noscript></p><p>Alternatively Simple.Data supports the delta approach too using <code>UpdateById</code></p><p class="minimal-gist"><script src='https://gist.github.com/1037804.js?file=SimpleDataUpdate2.cs'></script><noscript><pre><code>Simple.Data.Database.Open().Authors.UpdateById(    Id: 6,     FullName: "James Hughes");</code></pre></noscript></p><h3>Delete</h3><p>Finally Simple.Data has 2 ways to delete a record,</p><ul>    <li><code>DeleteById(id)</code></li>    <li><code>Delete(named_parameters)</code></li></ul><p class="minimal-gist"><script src='https://gist.github.com/1037813.js?file=SimpleDataDelete.cs'></script><noscript><pre><code>Simple.Data.Database.Open().Authors.DeleteById(3);Simple.Data.Database.Open().Authors.Delete(Id: 4);</code></pre></noscript></p><h2>There We Have It</h2><p>OK OK I guess this post feels a bit rushed.  I started out throwing lots of details into selects and stuff but this one just isn&#8217;t up to par.  I slowly discovered that I&#8217;d have to spend almost all my spare time covering all the aspects I wanted.  So I cut it back to a kind of &#8220;Starter for 10&#8221; approach.  Yeah thats right I&#8217;m leaving stuff up to you to ask and research :-P.  Anyway in these basic examples no one <span class="caps">ORM</span> really stands out too much.  Simple.Data is, as always, lovely and clean and PetaPoco offers a very flexible experience.  I like the ability to send deltas instead of full objects back (in case you hadn&#8217;t guessed) and I had a few annoyances around updates using Massive and Dapper but I think it was my own stupidity (I&#8217;ll update when I investigate).  If I had to choose between them I am still tending towards Simple.Data and PetaPoco (probably PetaPoco at this stage) but I do find all of them a much more pleasant experience vs. MyIbatis or NHibernate.</p><p>That should be enough to start anyone off on the right foot.</p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> Hehehehe IUDs</p><p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> You can pass a <span class="caps">SQL</span> string or a <span class="caps">SQL</span> builder as well but it&#8217;s fairly straightforward so I&#8217;ll not cover it here.  See the original <a href="http://yobriefca.se/blog/2011/06/16/microorms-for-dotnet-select-one"><span class="caps">SELECT</span> post</a> for a <span class="caps">SQL</span> and <span class="caps">SQL</span> Builder example.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MicroORMs for .NET: Stored Procedures]]></title>
    <link href="http://yobriefca.se/blog/2011/06/18/microorms-for-dotnet-stored-procedures/"/>
    <updated>2011-06-18T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/06/18/microorms-for-dotnet-stored-procedures</id>
    <content type="html"><![CDATA[<p>  <blockquote class="announce">This post is the is part of series of posts covering the various microORMs in the .<span class="caps">NET</span> world.  I intend to look at how each microORM meets certain data access and manipulation needs.  The current series includes,<ul>   <li><a href="http://yobriefca.se/blog/2011/06/15/microorms-for-dotnet">Obligatory Introduction Post</a></li>    <li><a href="http://yobriefca.se/blog/2011/06/16/microorms-for-dotnet-select-one">Syntax &#8211; SELECTs</a></li>   <li><a href="http://yobriefca.se/blog/2011/06/18/microorms-for-dotnet-stored-procedures">Stored Procedures</a></li> <li><a href="http://yobriefca.se/blog/2011/06/21/microorms-for-dotnet-inserts-updates-deletes">Inserts, Updates &amp; Deletes</a><br></li></ul></blockquote><p>As handy as running straight, fully-tailored SELECTs straight from your app code a lot of the time, especially in the &#8220;enterprise&#8221; world your <span class="caps">DBA</span> is going to insist that all operations go through tightly controlled stored procedures.  It&#8217;s all for the greater good I&#8217;m sure but flipsake it&#8217;s bloody annoying.</p><div style='font-family:"Courier New", Courier;color:#0b0;background-color:black; padding:1px 20px;font-size:0.9em;margin-left:20px;margin-right:20px;'><p><em>You are standing at the edge of a forest.  Ahead of you an old wooden sign sits at a slight angle.</em></p><p><strong>&gt;&gt; read sign</strong></p><p><em>You squint your eyes as you approach the sign and read the fading writing.  The sign reads</em></p><p style="padding-left:1em;"><em>&#8220;Welcome to the forest of microORMs.  You have nice eyes.  Have a <span class="caps">GREAT</span> day.&#8221;</em></p><p><strong>&gt;&gt; enter forest</strong></p><p><em>You walk, nay skip, into the forest.  A few minutes in you are confronted with a horribly gnarled beast.  The grumpy looking thing seems very out of place in this land of near tranquilty.  As you approach, it speaks</em></p><p style="padding-left:1em;"><em>&#8220;<span class="caps">GROAN</span> <span class="caps">GRUNT</span> Control <span class="caps">GROWL</span> Best Practise <span class="caps">WHEEZE</span> Enterprise Ready <span class="caps">SNARL</span>.  Little being&#8230; you may not pass any way you please.  That is not how we do things <span class="caps">GRUMBLE</span> <span class="caps">WHEEZE</span>. No to pass this way meatbag you must, yes must, take this route I have planned for you.  If you need to change your route I must approve it and construct it <span class="caps">COUGH</span> <span class="caps">GRUMBLE</span>.  There is limited scenery and not too many points to have fun&#8221;</em></p><p><strong>&gt;&gt; kill beast</strong></p><p><em>I&#8217;m afraid I can&#8217;t do that</em></p><p><strong>&gt;&gt; fffffffffffffffffffff..</strong></p></div><p>Fear not help is at hand.  So can we call sprocs using our microORMs, and if yes how?  Lets go see shall we?<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></p><h2>Dapper</h2><p>Dapper makes use of an extra parameter in its <code>Query&lt;T&gt;</code> method to specify a specific command type.  In this way it&#8217;s simply a matter of passing in the name of the sproc, the parameters and a <code>CommandType.StoredProcedure</code> as a named parameter.</p><p class="minimal-gist"><script src='https://gist.github.com/1032323.js?file=Dapper.cs'></script><noscript><pre><code>Author author = conn.Query&lt;Author&gt;(    "GetAuthorById",    new { Id = 1 },    commandType: CommandType.StoredProcedure).First();</code></pre></noscript></p><p>And boom thats it.  Same applies for multiple results.</p><h2>Massive</h2><p>Massive just works.</p><p class="minimal-gist"><script src='https://gist.github.com/1032340.js?file=Massive.cs'></script><noscript><pre><code>dynamic dyn = tbl.Query("GetAuthorById @0", 1).First();</code></pre></noscript></p><p>All I did was swap out the <span class="caps">SELECT</span> statement for the name of the sproc and Bobs Your Uncle.  Nice.</p><h2>PetaPoco</h2><p>PetaPoco has <em>some</em> support for sprocs.  For my needs in this article it works fine but apparently it doesn&#8217;t support output parameters <span class="caps">ATM</span>.  You need to prepend your call to the sproc with a DB specific command.</p><p class="minimal-gist"><script src='https://gist.github.com/1032349.js?file=PetaPoco.cs'></script><noscript><pre><code>Author a = db.Query&lt;Author&gt;("EXECUTE GetAuthorById @0", 1).First();</code></pre></noscript></p><p>The <code>EXECUTE</code> statement is database specific.  If you are using MySql you need to use <code>CALL</code> instead which kind of starts breaking the abstraction a bit.  I wonder if we will see this support getting more solidified in future releases.</p><h2>ServiceStack ORMLite</h2><p>At the time of writing this I couldn&#8217;t see any built in support for sprocs using ORMLite.  Either I am being my typical clueless self or we would just have to do it by hand.  Here is what I came up with,</p><p class="minimal-gist"><script src='https://gist.github.com/1032433.js?file=ORMLite.cs'></script><noscript><pre><code>Author author = dbFactory.Exec(dbCmd =&gt; {    dbCmd.CommandType = CommandType.StoredProcedure;    dbCmd.Parameters.Add(new SqlParameter("@id", 1));    dbCmd.CommandText = "GetAuthorById";    return dbCmd.ExecuteReader().ConvertTo&lt;Author&gt;();});</code></pre></noscript></p><p>It&#8217;s not exactly the worst thing in the world and I guess you could wrap this stuff in an extension method but still I feel spoilt by the other microORMs so far and this was a slight disappointment.  Perhaps someone could either confirm or deny sproc support in ORMLite?</p><h2>Simple.Data</h2><p>Simple.Data has lovely syntax for this.  You just call it as yet another dynamic method on the database object and Simple.Data just infers it for you.</p><p class="minimal-gist"><script src='https://gist.github.com/1032360.js?file=SimpleData.cs'></script><noscript><pre><code>Author author = Simple.Data.Database.Open().GetAuthorById(1).First();</code></pre></noscript></p><p>Yeah thats nice.</p><h2>Slightly Shorter and Summing Up</h2><p>So I didn&#8217;t want this one to have too much waffle (bar the odd text adventure here and there).  I was concerned that perhaps calling sprocs might be one of those requirements were the whole microORM stuff starts falling apart but no.  They actually handle the whole thing in a nice, clean manner.</p><p>Simple.Data is certainly starting to look more appealing to me and the whole fact that it&#8217;s not database specific (you&#8217;ve got NoSQL stores and even experimental things such as a Registry adapter &#8211; imagine this as part of Powershell).</p><p>Anyway some code snippets for this stuff are currently available in the <a href="https://github.com/kouphax/microorm-comparison">project/series github repo</a></p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> Not a real game.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MicroORMs for .NET: Syntax - SELECTs]]></title>
    <link href="http://yobriefca.se/blog/2011/06/16/microorms-for-dotnet-select-one/"/>
    <updated>2011-06-16T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/06/16/microorms-for-dotnet-select-one</id>
    <content type="html"><![CDATA[<p>  <blockquote class="announce">This post is the is part of series of posts covering the various microORMs in the .<span class="caps">NET</span> world.  I intend to look at how each microORM meets certain data access and manipulation needs.  The current series includes,<ul>   <li><a href="http://yobriefca.se/blog/2011/06/15/microorms-for-dotnet">Obligatory Introduction Post</a></li>    <li><a href="http://yobriefca.se/blog/2011/06/16/microorms-for-dotnet-select-one">Syntax &#8211; SELECTs</a></li>   <li><a href="http://yobriefca.se/blog/2011/06/18/microorms-for-dotnet-stored-procedures">Stored Procedures</a></li> <li><a href="http://yobriefca.se/blog/2011/06/21/microorms-for-dotnet-inserts-updates-deletes">Inserts, Updates &amp; Deletes</a><br></li></ul></blockquote><p>The two main things I want to look at in this article are</p><ol>    <li>Syntax of the microORM, specifically around,</li>   <li>Selecting single and multiple results</li></ol><p>So the most obvious starting point, bar the <a href="../15/microorms-for-dotnet/">boring introduction</a>, is how you perform selects using these awesome thingies.  To begin with lets get our playground set up.  Lets create a table of authors, lets call it <code>Authors</code><sup class="footnote" id="fnr0"><a href="#fn0">0</a></sup></p><script src='https://gist.github.com/1028123.js?file=createauthors.sql'></script><noscript><pre><code>CREATE TABLE Authors(  Id          int          IDENTITY(1,1) NOT NULL,  Username    varchar(50)                NOT NULL,  FullName    varchar(250)               NOT NULL,  CreatedDate datetime                   NOT NULL, CONSTRAINT PK_Authors PRIMARY KEY CLUSTERED (Id ASC))</code></pre></noscript><p>And populate it with some (meaningless) data<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>,</p><script src='https://gist.github.com/1028134.js?file=insertauthors.sql'></script><noscript><pre><code>INSERT INTO Authors(Username, FullName, CreatedDate) VALUES ('0@example.com', 'James Red', GETDATE());INSERT INTO Authors(Username, FullName, CreatedDate) VALUES ('1@example.com', 'Harry Black', GETDATE());-- ...CROPPED FOR BREVITY...INSERT INTO Authors(Username, FullName, CreatedDate) VALUES ('134@example.com', 'Chloe Green', GETDATE());</code></pre></noscript><p>Finally we need to create the equivalent C# object that our results can map to.  Again nothing too crazy here,</p><script src='https://gist.github.com/1028148.js?file=Author.cs'></script><noscript><pre><code>public class Author{    public int Id { get; set; }    public string Username { get; set; }    public string FullName { get; set; }    public DateTime CreatedDate { get; set; }}</code></pre></noscript><p>So now the stage is set and it&#8217;s time for our microORMs to play their part.</p><h2>Selecting Single and Multiple Authors</h2><p>So lets assume we want to do 2 things -</p><ul>  <li>Select a single author with an Id of 1, and,</li>   <li>Select multiple authors whose username (in this case the users email address) ends with <em>example.com</em>.</li></ul><h3>Dapper</h3><p>Dapper has a single way of querying your database and it offers this via an extension method on the standard <code>SqlConnection</code> class,</p><script src='https://gist.github.com/1028156.js?file=DapperSelect.cs'></script><noscript><pre><code>using (SqlConnection conn = new SqlConnection(ConnectionString)){    conn.Open();    Author a = conn.Query&lt;Author&gt;(        "SELECT * FROM Authors WHERE Id = @Id",         new { Id = 1 }).First();}</code></pre></noscript><p>As you can see I&#8217;ve just opened a normal connection using a ConnectionString property I pulled from my <code>App.config</code>&#8217;s ConnectionString config block.  The magic here lies in the <code>Query&lt;Author&gt;</code> method.  This method accepts a parameterised <span class="caps">SQL</span> string and maps the result back into the object you specified.  Ultra simple, ultra clean.  There are a whole host of other arguments to the <code>Query&lt;T&gt;</code> method but it would fill this post up pretty fast.</p><p>Selecting multiple object simply requires me to change the query to meet the new requirements,</p><script src='https://gist.github.com/1028838.js?file=DapperSelectMany.cs'></script><noscript><pre><code>IEnumerable&lt;Author&gt; dapperA = conn.Query&lt;Author&gt;(    "SELECT * FROM Authors WHERE Username LIKE @PartialUsername",    new { PartialUsername = "%example.com" });</code></pre></noscript><p>One of the features I really liked apart from the simplicity of the whole thing was the parameterised <span class="caps">SQL</span>.  Many of the frameworks support this but most support it by index based assignment e.g. &#8220;<span class="caps">WHERE</span> Id=@0&#8221;.  Thats fine but Dappers use of an anonymous object makes the whole thing that little bit nicer. No need to refactor strings should your arguments move around (it has happened) and it all reads just that tiny bit better as well.</p><p>Dapper also offers a non-generic <code>Query</code> method that returns instances of <code>dynamic</code> objects but I&#8217;m still to be convinced that this is useful when pushing these models into and back out of views etc.  Still it&#8217;s nice to have for those times that creating another model would be overkill.</p><h3>Massive</h3><p>Massive is slightly different to the other microORMs in that it only deals with <code>dynamic</code> objects from queries.  This means if you need concrete models you will have to map them either manually or use a tool to help (such as <a href="http://automapper.codeplex.com/">AutoMapper</a>).  Due to my schema (pluarl table names) I use Massive in a slightly different way to most people.  Massive requires your models to extend <code>Massive.DynamicModel</code> so to keep things clean I tended to naturally create a model that represents my Authors table,</p><script src='https://gist.github.com/1028975.js?file=MassiveAuthors.cs'></script><noscript><pre><code>public class Authors : Massive.DynamicModel{    public Authors()        : base("DefaultConnectionString")    {        PrimaryKeyField = "Id";    }}</code></pre></noscript><p>This provides an entry point for configuring how Massive connects to your database.  The <code>DynamicModel</code> has a constructor that allows us to specify a connection string name that Massive will lookup from the <code>Web/App.config</code> <code>ConnectionStrings</code> config section.  Alternatively if you don&#8217;t supply this Massive will grab the first one it finds.  This class also allows us to specify the table name (in this case inferred from the class name) and properties such as the primary key of the table (as shown above).</p><p>Now we have our class defined we can start selecting from the database.  To select a single object we can use the <code>Single</code> method.</p><script src='https://gist.github.com/1029000.js?file=MassiveSelectOne.cs'></script><noscript><pre><code>Authors table = new Authors();dynamic result = table.Single(1);Author author = Authors.Map(result);</code></pre></noscript><p>You&#8217;ll notice I&#8217;ve made another step here and that is mapping the <code>dynamic</code> result to a concrete <code>Author</code> object.  It&#8217;s a simple mapping method added to the <code>Authors</code> object but could be made more generic fairly easiy,</p><script src='https://gist.github.com/1029005.js?file=MassiveAuthorMap.cs'></script><noscript><pre><code>public static Author Map(dynamic obj){    return new Author    {        Id = obj.Id,        CreatedDate = obj.CreatedDate,        FullName = obj.FullName,        Username = obj.Username    };}</code></pre></noscript><p>Selecting multiple objects can be done in 2 ways using <code>All</code> which returns the entire table and then you filter or using the <code>Query</code> method (preferred unless you really want to return the entire table for refdata or something I guess)</p><script src='https://gist.github.com/1029015.js?file=MassiveSelectMany.cs'></script><noscript><pre><code>var tbl = new Authors();IList&lt;dynamic&gt; dyn = tbl.Query(    "SELECT * FROM Authors WHERE Username LIKE @0",     "%example.com");</code></pre></noscript><div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> Rob, the creator of Massive, has just pushed <a href="http://wekeroad.com/post/6618062904/changed-my-mind-massive-changed-to-embrace-c">a new type of query syntax</a> into Massive.  The new approach makes use of named parameters</p><script src='https://gist.github.com/1031800.js?file=MassiveExample.cs'></script><noscript><pre><code>dynamic db = new Products();var products = db.FindBy(    CategoryID:8,    UnitPrice:100);</code></pre></noscript><p>I haven&#8217;t rewritten my stuff in this post but I want to close this post off and move on.  There is plenty more info in the <a href="http://wekeroad.com/post/6618062904/changed-my-mind-massive-changed-to-embrace-c">original post</a></p></div><h3>PetaPoco</h3><p>PetaPoco has a number of way of selecting single objects, or more specifically multiple ways of building/manipulating <span class="caps">SQL</span> queries.  But before we do that we need to get access to the database.  We do this via the <code>PetaPoco.Database</code> object which is an <code>IDisposable</code> wrapper around a Database connection that gives us the PetaPoco magic.</p><script src='https://gist.github.com/1029030.js?file=PetaPocoDatabase.cs'></script><noscript><pre><code>using (PetaPoco.Database db = new PetaPoco.Database("DefaultConnectionString")){    // query goes here}</code></pre></noscript><div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> <a href="http://twitter.com/toptensoftware">Brad Robinson</a> has informed me that the <code>using</code> statement is unnecessary</p><blockquote><p>You don&#8217;t need to explicitly dispose the database object unless you&#8217;ve called OpenSharedConnection yourself. The idea is that if you&#8217;re using an <span class="caps">IOC</span> container to instantiate per-http-context instances you can call OpenSharedConnection at the start of the request and a single connection will be used for the entire http request. In practice I&#8217;ve found this not really necessary as most providers do connection pooling anyway. In other words, generally the using clause is not necessary.</p></blockquote></div><p>The Database constructor takes a name of a defined connection string to use for connecting to the database.  Now we are ready to start writing our query,</p><p><strong>Using Single(id)</strong></p><script src='https://gist.github.com/1029032.js?file=PetaPocoSelect.cs'></script><noscript><pre><code>Author a = db.Single&lt;Author&gt;(1);</code></pre></noscript><p><strong>Using Custom Parameterised <span class="caps">SQL</span></strong></p><script src='https://gist.github.com/1029033.js?file=PetaPocoSelect.cs'></script><noscript><pre><code>Author b = db.Single&lt;Author&gt;("SELECT * FROM Authors WHERE Id = @0", 1);</code></pre></noscript><div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> <a href="http://twitter.com/toptensoftware">Brad Robinson</a> pointed out that it is also possible to used named parameters as discussed in the Dapper section above <code>@MyNamedParam</code> instead of <code>@0</code>.  The niceness just keeps coming with PetaPoco</p></div><p><strong>Using <span class="caps">SQL</span> Builder to Append Statements</strong></p><script src='https://gist.github.com/1029034.js?file=PetaPocoSelect.cs'></script><noscript><pre><code>Author c = db.Single&lt;Author&gt;(    PetaPoco.Sql.Builder        .Append("SELECT * FROM Authors")        .Append("WHERE Id = @0", 1));</code></pre></noscript><p><strong>Using <span class="caps">SQL</span> Builders Fluent Syntax to Append Statements</strong></p><script src='https://gist.github.com/1029036.js?file=PetaPocoSelect.cs'></script><noscript><pre><code>Author d = db.Single&lt;Author&gt;(    PetaPoco.Sql.Builder        .Select("*")        .From("Authors")        .Where("Id = @0", 1));</code></pre></noscript><p>See what I mean?  Lots of ways.  Now I guess the 3rd and 4th methods will probably seem a bit <acronym title="Over The Top"><span class="caps">OTT</span></acronym> for this simple select but think how powerful these would be if we had to conditionally build up our where clause or select statement based on a number of user defined conditions.  Nice.</p><p>Selecting multiple objects offers the same sort of variety except we can use either <code>Query</code> or <code>Fetch</code>.  The difference between the two is summed up by the PetaPoco site,</p><blockquote><p>These are pretty much identical except <code>Fetch</code> returns a List&lt;&gt; of POCO&#8217;s whereas <code>Query</code> uses <code>yield return</code> to iterate over the results without loading the whole set into memory.</p></blockquote><p>So what I say about <code>Query</code> applies to <code>Fetch</code> as well.  Retrieving multiple objects is done in the same way as selecting a single object in that you can give the method parameterised <span class="caps">SQL</span> or use the <span class="caps">SQL</span> builder to construct the query.</p><script src='https://gist.github.com/1029078.js?file=PetaPocoSelectMany.cs'></script><noscript><pre><code>IEnumerable&lt;Author&gt; authors = db.Query&lt;Author&gt;(    "SELECT * FROM Authors WHERE Username LIKE @0",     "%example.com");</code></pre></noscript><p>So to cover this off a full select using PetaPoco will would look like this.</p><script src='https://gist.github.com/1029081.js?file=PetaPocoSelectFull.cs'></script><noscript><pre><code>using (PetaPoco.Database db = new PetaPoco.Database("DefaultConnectionString")){    Author q = db.Single&lt;Author&gt;("SELECT * FROM Authors WHERE Id = @0", 1);}</code></pre></noscript><p><span class="caps">IMO</span> The syntax is nice, clean and flexible.  One thing about PetaPoco that is a <span class="caps">VERY</span> minor pain point for me is that it assumes singular name for tables which contradicted my earlier decision.  Not to worry PetaPoco uses attributes against the model class to manipulate the standard configuration and I can specify a class level attribute of <code>[PetaPoco.TableName("Authors")]</code> to put things right with the world.  This also only applies to the queries that use object inference such as <code>Single&lt;T&gt;</code> and not to the methods that accept <span class="caps">SQL</span>.</p><h3>ServiceStack ORMLite</h3><p>ORMLite from ServiceStack does things a wee bit differently to the rest.  It&#8217;s a bit less self-contained because it also applies extension methods to the string object as well.  Also like PetaPoco it takes the singular naming convention for Object Name &rarr; Table Name so first things first we need to annotate our <code>Author</code> model with another attribtue</p><script src='https://gist.github.com/1029204.js?file=ServiceStackAtribute.cs'></script><noscript><pre><code>[ServiceStack.DataAnnotations.Alias("Authors")]</code></pre></noscript><p>Another thing we need to do once before hand is set the dialect the ORMLite will use.  This is so it knows how to speak to the specific database type we created.  Typically you would put this in something like <code>Global.asax.cs</code>, <code>Program.cs</code> or whatever bootstrapper you care to use as it needs done only once.</p><script src='https://gist.github.com/1029116.js?file=Dialect.cs'></script><noscript><pre><code>OrmLiteConfig.DialectProvider = new SqlServerOrmLiteDialectProvider();</code></pre></noscript><p>Now we can go ahead and start selecting things like a boss,</p><script src='https://gist.github.com/1029120.js?file=ORMLiteSelectSingle.cs'></script><noscript><pre><code>using (IDbConnection db = "...".OpenDbConnection())using (IDbCommand cmd = db.CreateCommand()){    Author rows = cmd.GetById&lt;Author&gt;(1);}</code></pre></noscript><p>And for selecting many</p><script src='https://gist.github.com/1029129.js?file=ORMLiteSelectMany.cs'></script><noscript><pre><code>using (IDbConnection db = Program.ConnectionString.OpenDbConnection())using (IDbCommand cmd = db.CreateCommand()){    List&lt;Author&gt; rows = cmd.Select&lt;Author&gt;(        "Username LIKE {0}",         "%example.com");}</code></pre></noscript><p>Alternatively if we want to perform a specific operation on each result we can use the <code>Each&lt;T&gt;</code> to iterate over the result set rather than simply return it.</p><p>As you can see you don&#8217;t need to specify a full <span class="caps">SQL</span> query, just the <span class="caps">WHERE</span> clause which makes everything look a little bit neater and avoids repeating unnecessary portions of <span class="caps">SQL</span> that could be inferred.</p><p>ORMLite&#8217;s syntax is <em>slighlty</em> more complex &#8211; it feels a bit closer to the metal.  But it&#8217;s certainly not horribly different that it would put me off using it.</p><div class="update"><p><strong><span class="caps">UPDATE</span>:</strong> It seems there is another way to query the database that makes things a bit shorter.  Thanks to mythz (in the comments) for this one.</p><script src='https://gist.github.com/1030717.js?file=Alternative.cs'></script><noscript><pre><code>IDbConnectionFactory dbFactory = new OrmLiteConnectionFactory("...",     SqlServerOrmLiteDialectProvider.Instance);Author author = dbFactory.Exec(dbCmd =&gt; dbCmd.GetById&lt;Author&gt;(1));List&lt;Author&gt; rows = dbFactory.Exec(dbCmd =&gt;   dbCmd.Select&lt;Author&gt;("Username LIKE {0}", "%example.com"));</code></pre></noscript><p>I agree that this is a viable alternative and can make for shorter code.  Thanks.</p></div><h3>Simple.Data</h3><p>Finally Simple.Data offers a very clean syntax that mixes dynamic with concrete results.  The first thing you need to do with Simple.Data is get a handle on the Database object that is returned as a special <code>dynamic</code> object.  There are a number of ways of doing this,</p><script src='https://gist.github.com/1029142.js?file=SimpleData.cs'></script><noscript><pre><code>Simple.Data.Database.Open();Simple.Data.Database.OpenNamedConnection("DefaultConnectionString");Simple.Data.Database.OpenConnection(Program.ConnectionString);</code></pre></noscript><p>By using <code>Database.Open()</code> Simple.Data will look for a connection string called <code>Simple.Data.Properties.Settings.DefaultConnectionString</code> and use it to create the database instance.  Alternatively you can specify a specific named connection using <code>Database.OpenNamedConnection</code> or even a raw connection string using <code>Database.OpenConnection</code></p><p>These methods all return a special <code>dynamic</code> object that dynamically creates a <span class="caps">SQL</span> statement by constructing methods on the fly.  It&#8217;s best to look at the code for this.  To select a single object we can do this,</p><script src='https://gist.github.com/1029154.js?file=SimpleDataFind.cs'></script><noscript><pre><code>Author author = Simple.Data.Database.Open().Author.FindById(1);</code></pre></noscript><p>So whats happening here.  Well firstly we a asking it to look at the Authors table.  Next we are telling it to FindById &#8211; but this method doesn&#8217;t exist. We could easily have said FindByUsernameAndEmail and we would get the results we expected.  This bit of metaprogramming is the magic behind Simple.Data where method signatures are parsed and used to build <span class="caps">SQL</span>.  Nice stuff.  I still have a bit of issue working with dynamic objects but in this case my models are concrete so it&#8217;s really not an issue.</p><p>Selecting multiple objects is that same except instead of <code>FindByXXX</code> we use <code>FindAllByXXX</code> and as this query returns a <code>SimpleQuery</code> object we then need to perform a <code>.Cast&lt;Author&gt;</code> at the end to get back a list of authors.</p><p>An alternative and more flexible way of doing queries is using <code>Find</code> and <code>FindAll</code>.  These methods let you specify more complex queries.  To implement our <code>LIKE</code> comparison for our query above we need to use <code>FindAll</code> like so,</p><script src='https://gist.github.com/1029181.js?file=SimpleDataSelectMany.cs'></script><noscript><pre><code>dynamic authors = Simple.Data.Database.Open().Authors;IEnumerable&lt;Author&gt; authors = authors    .FindAll(authors.Username.Like("%.com"))    .Cast&lt;Author&gt;();</code></pre></noscript><p>This also shows the use of the <code>Cast&lt;T&gt;</code> mentioned above.  We can supply a variable number of arguments to <code>Find</code> and <code>FindAll</code> as well as using different comparison operators.</p><h2>That Was a Long One<sup class="footnote" id="fnr2"><a href="#fn2">2</a></sup></h2><p>So yeah not only have I touched on selecting single and multiple object at a high level I also had to add a bit of discussion around setting things up so I apologise for the length of this post.  On the plus side discussing configuration alone for MyBatis and nHibernate would probably take the same length of time.  Thats whats great about these microORMs 99% of the time you don&#8217;t need all that set up for most projects.  No need getting bogged down in configuration when it&#8217;s not actually achieving anything.</p><p>In terms of the syntax &#8211; so far I am quite taken by both Simple.Data and PetaPoco but that could change when I start really pushing things &#8211; after all everyone can do selects quite easily.</p><p>In terms of dynamic results (e.g. from Massive) I&#8217;m still to be convinced on their usefulness without having to always map to concrete classes.  I don&#8217;t see how this helps refactoring (it looks like it makes it much worse) nor do I see how it works with most validation mechanisms.  But I would love to be proven wrong on this please.</p><p>One thing I do know &#8211; it&#8217;s going to take a lot more justification for someone to use a heavyweight <span class="caps">ORM</span> in my next project.  While I not willing to declare the death of ORMs like some other people I am certainly leaning in that direction.</p><p>Source for this series is slowly evolving in a <a href="https://github.com/kouphax/microorm-comparison">Github repo</a> if you feel inspired to have a poke around.</p><p class="footnote" id="fn0"><a href="#fnr0"><sup>0</sup></a> We can argue about plural or singular data naming conventions some other time, or in the comments!!!</p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> I created a load of test data using the handy little tool <a href="http://autopoco.codeplex.com/">AutoPoco</a></p><p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> &#8220;Thats what she said&#8221; &lt;self:facepalm&gt;</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MicroORMs for .NET: (Obligatory) Introduction (Post)]]></title>
    <link href="http://yobriefca.se/blog/2011/06/15/microorms-for-dotnet/"/>
    <updated>2011-06-15T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/06/15/microorms-for-dotnet</id>
    <content type="html"><![CDATA[<p>  <blockquote class="announce">This post is the is part of series of posts covering the various microORMs in the .<span class="caps">NET</span> world.  I intend to look at how each microORM meets certain data access and manipulation needs.  The current series includes,<ul>   <li><a href="http://yobriefca.se/blog/2011/06/15/microorms-for-dotnet">Obligatory Introduction Post</a></li>    <li><a href="http://yobriefca.se/blog/2011/06/16/microorms-for-dotnet-select-one">Syntax &#8211; SELECTs</a></li>   <li><a href="http://yobriefca.se/blog/2011/06/18/microorms-for-dotnet-stored-procedures">Stored Procedures</a></li> <li><a href="http://yobriefca.se/blog/2011/06/21/microorms-for-dotnet-inserts-updates-deletes">Inserts, Updates &amp; Deletes</a><br></li></ul></blockquote><p>I&#8217;ve been playing, somewhat superficially, with a few MicroORMs in .<span class="caps">NET</span> for a while now.  While I have yet to use any in a real project I wanted to do a bit of comparison series.  It&#8217;s a bit selfish I guess as I am actually writing this series as a means to get myself up to speed on these frameworks as well as inform others about perils I faced as a newcomer to them as and when I hit those pain points.</p><p>To be honest I&#8217;ve never been a fan of the Data Access layer in projects &#8211; Databases are fine I guess and the application layer is all good but that thin layer between the two just frustrates me.  It&#8217;s often needlessly over complicated, confusing, hacked together or just plain broken.  Most of my experience is with <a href="http://www.mybatis.org/dotnet.html">iBatis/MyBatis</a> and it &#8220;does the job&#8221; but its very fiddly and <span class="caps">XML</span> configuration becomes cumbersome for simple tasks.  I&#8217;ve also tinkered with other things like Entity Framework and NHibernate but more often than not they just don&#8217;t feel right.</p><p>This make microORMs sound appealing to me for the very same reasons.  They give you just enough to get the job done, prefer convention over configuration and generally allow you to get right down to the metal and tweak things using <span class="caps">SQL</span> &#8211; easily the best <span class="caps">DSL</span> for working with databases.  Sure they may lack many features but typically these are features you wouldn&#8217;t really miss if taken away from you.</p><h2>The MicroORMs</h2><p>There are a number of ORMs currently available for .<span class="caps">NET</span> and I am going to look at a few of them in terms of features and syntax.<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup></p><h3><a href="http://code.google.com/p/dapper-dot-net/">Dapper</a></h3><p>Dapper was created by Sam Saffron from <a href="http://stackoverflow.com">Stackoverflow</a>. Rather than a library Dapper is a single file that you can drop into your project and applies some syntactic sugar to extend your IDbConnection interface.</p><h3><a href="https://github.com/robconery/massive">Massive</a></h3><p>Like Dapper, Massive is a single file rather than a library and offers a very similar feature set to Dapper except it works exclusively with the .NET4 <code>dynamic</code> stuff.</p><h3><a href="http://www.toptensoftware.com/petapoco/">PetaPoco</a></h3><p>PetaPoco came out of inspiration from Massive and has extended to support real objects as well as some very nice extra features such as T4 templating, configuration via model attributes and other nice stuff.</p><h3><a href="https://github.com/markrendle/Simple.Data">Simple.Data</a></h3><p>Simple.Data is A lightweight, dynamic data access component that make use of convention and <code>dynamic</code> to allow users to access database tables via dynamically generated methods.</p><h3><a href="https://github.com/ServiceStack/ServiceStack.OrmLite">ORMLite</a></h3><p>ServiceStack.OrmLite is a convention-based, configuration-free lightweight <span class="caps">ORM</span> that uses standard <span class="caps">POCO</span> classes and Data Annotation attributes to infer its table schema.</p><h2>On with the show</h2><p>So thats my toys all laid out and ready to be played with.  Next step is to look at some of the typical operations for selecting and manipulating data from our database.  I hope to have the first real part of this investigation up shortly (or before the decade is out at least).</p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> This list is not exhaustive there are a few specialised ones around as well which I may touch on later in the series.</p></p>
]]></content>
  </entry>
  
</feed>
