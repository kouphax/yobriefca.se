<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>PhoneGap | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/phonegap/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2012-11-05T08:53:00+00:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rolling Your Own PhoneGap with MonoTouch]]></title>
    <link href="http://yobriefca.se/blog/2011/12/05/rolling-your-own-phonegap-with-monotouch/"/>
    <updated>2011-12-05T20:11:00+00:00</updated>
    <id>http://yobriefca.se/blog/2011/12/05/rolling-your-own-phonegap-with-monotouch</id>
    <content type="html"><![CDATA[<p><a href="http://phonegap.com/">PhoneGap</a> is a clever little idea.  Take a transparent native wrapper for a mobile platform, stretch a 100% x 100% web view and provide a JavaScript API that acts as a bridge to native methods that control the device features such as cameras, GPS and Contacts.  It brings all those lovely web people into the mobile space.  Truth be told PhoneGap isn't powered by flaked unicorn and rainbow essence - it's fairly simple to achieve yourself.</p>

<!-- more -->


<p>So I was thinking, as I do when I am bored, that it would be super awesome if MonoTouch could do the PhoneGap.  Turns out there have been some attempts in the past to create bindings but I barely understand the posts so I felt disappointed.  Then curious.  Then I started hacking.  Then happy.  Then bored again.  The happy once more.  Then slightly frustrated.  Finally I started writing this post and I think I feel a bit tired because it's late an I've had a hard day.</p>

<p>Anyway what follows is a very primitive start to what is essentially a PhoneGap, possibly NimbleKit, for MonoTouch.  Thats cool becuase not only would you be saying "Screw You Objective-C!!" by using MonoTouch but you'd be sort of saying "Hey MonoTouch - HTML5 just had your mum, twice" as well.  Hey I'd use a NimbleKit/PhoneGap-like framework for MonoTouch if it was available and offered a clever way of mixing Native with Web but thats just me.  Hence I am writing this post.</p>

<h2>The Recipe</h2>

<p>There are various components that would make up a framework like this.</p>

<ol>
<li>A fullscreen Web View (lets call it the webside)</li>
<li>A controller that handles requests from the webside (lets call it the nativeside)</li>
<li>A JavaScript API on the webside that talks to the nativeside</li>
</ol>


<p>Simple enough so lets start proving things.</p>

<h3>The Webside</h3>

<p>Using a simple Single View iPhone Project in MonoDevelop I added some local resources.</p>

<p>{% codeblock %}</p>

<pre><code>|
|_ www
| |_ index.html
|
|_ AppDelegate.cs
|_ MainViewController.cs
</code></pre>

<p>{% endcodeblock %}</p>

<p>For now the index.html file has some basic content</p>

<p>{% codeblock lang:html %}
&lt;!DOCTYPE html>
<html></p>

<pre><code>&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello UIWebView&lt;/h1&gt;
&lt;/body&gt;
</code></pre>

<p></html>
{% endcodeblock %}</p>

<p>Next up I created a full screen <code>UIWebView</code> and asked it to point to the <code>index.html</code> I just created in <code>wwww</code> folder (which by the way should be set as "Content".</p>

<p>{% codeblock lang:csharp %}
public override void ViewDidLoad ()
{</p>

<pre><code>base.ViewDidLoad ();

using (UIWebView view = new UIWebView(new RectangleF(0f, 0f, 320f, 460f)))
{
    // obtain path to actual content file
    string path = NSBundle.MainBundle.PathForResource("www/index", "html");

    // create an address and escape whitespace
    string address = string.Format("file:{0}", path).Replace(" ", "%20");

    // create url and request
    NSUrl url = new NSUrl(address);
    NSUrlRequest request = new NSUrlRequest(url);

    // load request and add to main ?view
    view.LoadRequest(request);
    this.View.AddSubview(view);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Running this gives us what we would expect (I hope you expect this otherwise I'd be worried).</p>

<p><img src="/images/blog/monotouch-phonegap/capture1.png" alt="Sample Output for Web View" /></p>

<p>Webside more or less spiked for now.  Next up the nativeside.</p>

<h3>The Nativeside</h3>

<p>So how is the native stuff supposed to respond to requests made via the mysterious JavaScript API from the webside.  The approach that makes the most sense here is to set up an internal HttpListener that reacts to web requests.  This means we can, thanks to the lack of a Same Origin Policy in UIWebViews via the <code>file://</code> protocol, make Ajax requests to said listener to do stuff and return appropriate responses.</p>

<p>In the AppDelegate class I created a basic HttpListener that simply returns a simple JSON response of true if a request is made.</p>

<p>{% codeblock lang:csharp %}
public HttpListener listener;</p>

<p>public void HandleRequest (IAsyncResult result)
{</p>

<pre><code>//Get the listener context
HttpListenerContext context = listener.EndGetContext(result);

//Start listening for the next request
listener.BeginGetContext(new AsyncCallback(HandleRequest), listener);

string response = "true";
byte[] responseBytes = System.Text.Encoding.UTF8.GetBytes(response);

context.Response.ContentType = "text/json";
context.Response.StatusCode = (int)HttpStatusCode.OK;
context.Response.ContentLength64 = responseBytes.Length;
context.Response.OutputStream.Write(responseBytes, 0, responseBytes.Length);
context.Response.OutputStream.Close();
</code></pre>

<p>}</p>

<p>public override bool FinishedLaunching (UIApplication app, NSDictionary options)
{</p>

<pre><code>window = new UIWindow (UIScreen.MainScreen.Bounds);

viewController = new JsBridgeViewController ();
window.RootViewController = viewController;
window.MakeKeyAndVisible ();

listener = new HttpListener();
listener.Prefixes.Add("http://*:30001/");
listener.Start();

listener.BeginGetContext(new AsyncCallback(HandleRequest), listener);

return true;
</code></pre>

<p>}
{% endcodeblock %}</p>

<h3>The Final Step - The Bridge</h3>

<p>So we need to talk to this "server" from our JavaScript.  Easy stuff - for now we just make a simple ajax call to our endpoint in the <code>index.html</code> (synchronous for code simplicity).</p>

<p>{% codeblock lang:html %}</p>

<script type="text/javascript">
    var request = new XMLHttpRequest();
    request.open('GET','http://127.0.0.1:30001/', false);
    request.send();

    if(request.status == 200){
        alert(JSON.parse(request.responseText));
    }
    else{
        alert("Error");
    }

</script>


<p>{% endcodeblock %}</p>

<p>Running this once again reveals that all is sweet...</p>

<p><img src="/images/blog/monotouch-phonegap/capture2.png" alt="Sample Output for Web View with Nativeside call" /></p>

<h2>Now What?</h2>

<p>Well thats about as far as I've actually gotten but this is far enough to satisfy myself that it's possible to talk between the web view and the native stuff.  Yeah I know it's not rocket science but I needed to prove this to myself.  So whats next?  Well I want see what I can do with regards to making real calls to real things, perhaps even venture into NimbleKit territory and generate native elements such as ViewControllers and Tabs - who knows!</p>

<p><em>(MYSTERIOUS EXIT MUSIC)</em></p>

<p><em>(FADE TO BLACK)</em></p>

<p>To Be Continued...</p>

<p><em>(EVIL CACKLE HEARD IN THE DISTANCE)</em></p>

<p><em>(END SCENE)</em></p>
]]></content>
  </entry>
  
</feed>
