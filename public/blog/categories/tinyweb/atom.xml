<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>Tinyweb | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/tinyweb/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2012-03-19T13:41:13+00:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tinyweb.FluentSecurity v0.1 Released]]></title>
    <link href="http://yobriefca.se/blog/2011/10/19/tinyweb-fluentsecurity-0-1-released/"/>
    <updated>2011-10-19T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/10/19/tinyweb-fluentsecurity-0-1-released</id>
    <content type="html"><![CDATA[<blockquote><p>Slight change here - FluentSecurity is now FluentAuth to avoid any confusion with a similarly named product of which there is some inspiration taken.  Anyway on with the original post....</p></blockquote>

<p><img src="http://yobriefca.se/projects/fluentauth/images/logo.png" style="float:right;height:150px;" /></p>

<p>I have procrastinated long enough on this and it was blocking some of the other work I wanted to get on with.  I have just pushed v0.1 to Nuget and launched the <a href="http://yobriefca.se/projects/fluentauth/">site sans documentation</a>.</p>

<!--more-->


<p>Not a great deal has changed since my last announcement, well it has but it hasn't been documented as it should be backwards compatible.  Just a few more configuration options that I'll explain once I get the documentation rolled out.</p>

<script type="text/javascript">
    (function () {
        var nb = document.createElement('script'); nb.type = 'text/javascript'; nb.async = true;
        nb.src = 'http://s.prabir.me/nuget-button/0.2.1/nuget-button.min.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(nb, s);
    })();
</script>


<pre class="nuget-button">Install-Package Tinyweb.FluentAuth</pre>


<p>So go check it out and hopefully you'll find it useful - plenty of plans for expansion to other frameworks and some more API changes coming too.  Now back to procrastinating.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tinyweb Fluent Security]]></title>
    <link href="http://yobriefca.se/blog/2011/09/26/tinyweb-fluentsecurity/"/>
    <updated>2011-09-26T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/09/26/tinyweb-fluentsecurity</id>
    <content type="html"><![CDATA[<p>I've been working on a little project recently that is using Tinyweb.  It's a typical little CRUDdy app and makes use of typical security features in a web app.  Tinyweb itself doesn't provide any sort of custom security features out of the box but as it sits on top of ASP.NET you can avail of all the normal membership stuff.  Problem is though - the default membership stuff, when working directly with it, is a bit cumbersome.  I recently tinkered with a project for ASP.NET MVC called <a href="http://www.fluentsecurity.net/">FluentSecurity</a> that added a fluent syntax to configuring security for ASP.NET MVC applications.  Taking a healthy dose of inspiration from this project I rolled a lightweight Tinyweb version of my own.  I figure this might be useful to someone else so I have now created a new project specifically for this.  It's probably totally broken in areas but the areas I've written tests around appear to work.</p>

<p>The source is available in a <a href="https://bitbucket.org/kouphax/tinyweb-fluentsecurity">BitBucket repository</a> so feel free to critique.  Once I get it tested better, documents written up and generally applied a bit of sipt and polish I'll push it to Nuget and the fun can really begin.</p>

<h1>Tinyweb.FluentSecurity</h1>

<p>FluentSecurity comes as a 2 part solution</p>

<ol>
<li>The <code>Security</code> class is the main entry point for configuring FluentSecurity and authenticating users</li>
<li>The <code>SecurityFilter</code> class is a Tinyweb filter that performs auth tests on the current request</li>
</ol>


<h2>Security</h2>

<p>The <code>Security</code> class provides a central location to configure FluentSecurity.  <code>Security</code> is also responsible for executing the auth tests you pass to it.</p>

<h3>Security.Configure(Action<Configurator> configurator)</h3>

<p><code>Configure</code> lets you define the configuration for you module.  It accepts an Action that can be used to define rules for each handler.  For example</p>

<pre><code>Security.Configure(c =&gt;
{
    c.For&lt;RootHandler&gt;().DenyAnonymousAccess();
    c.For&lt;AdminHandler&gt;().RequireRoles("Admin");
    c.For&lt;UserHandler&gt;().DenyRoles("Admin");
    c.For&lt;SecretHandler&gt;().AllowVerbs(Security.AllowedVerbs.GET | Security.AllowedVerbs.POST);
});

Tinyweb.Init();
</code></pre>

<p>We call <code>Security.Configure</code> just before we Init Tinyweb (though it can be done at anytime realistically speaking).  The configuration block shows off most of the ways you can configure handlers e.g.</p>

<ol>
<li><code>DenyAnonymousAccess</code> will prevent, as the name suggests, all anonymous users from accessing this handler</li>
<li><code>RequireRoles</code> specifes 1..N roles that are required to access this handler</li>
<li><code>DenyRoles</code> specifies 1..N roles that aren't permitted to access this handler</li>
<li><code>AllowVerbs</code> restricts the HTTP Verbs that can be used to access this handler (PUT, POST, GET etc.)</li>
<li><code>WithCustomRule</code> (not listed) allows you to specify a function that can be used to apply a custom rule to each request</li>
</ol>


<p>Each method returns the configuration object so it is possible to chain the calls to create more complex rules.</p>

<pre><code>Security.Configure(c =&gt;
    c.For&lt;EditHandler&gt;()
        .DenyAnonymousAccess()
        .RequireRoles("Author")
        .DenyRoles("Reader")
        .AllowVerbs(Security.AllowedVerbs.POST);
</code></pre>

<p>Obviously some combinations will not make sense, in fact AllowedVerbs needs to be tweaked as it may only apply to certain roles (so the combinations don't make sense right now).  Currently FluentSecurity doesn't care and it probably never will if you try and create illogical combinations.</p>

<h3>bool Security.Test(RequestContext req, HandlerData d)</h3>

<p>This will run all pre-configured rules against the current request to determine if the request is authorised to continue.  It will return a true/false result depengin on whether the rules pass or not.</p>

<pre><code>bool granted = Security.Test(context, data);
</code></pre>

<h3>IResult Security.Validate(RequestContext req, HandlerData d)</h3>

<p>Implements the typical SecurityFilter use case.  This function will call the <code>Test</code> method and returns <code>Result.None()</code> if the test passes (may be configurable in the future) otherwise it executes the <code>Security.OnAccessDenied</code> function and returns the <code>IResult</code>.  If no <code>OnAccessDenied</code> is defined <code>Result.None()</code> will be returned.</p>

<pre><code>IResult result = Security.Validate(context, data);
</code></pre>

<p>This is simply shorthand for now but may be expanded with some custom logic in the near future.</p>

<h3>Security.OnAccessDenied</h3>

<p>This property is used to define a function that can be used to return a result should access been denied.  This is done lazily as it allows you access to the <code>RequestContext</code> and <code>HandlerData</code> so you could implement per-request handling of the Result (redirects or return URLs etc.)</p>

<pre><code>Security.OnAccessDenied = (c, d) =&gt; Result.Redirect&lt;AccessDeniedHandler&gt;();
</code></pre>

<h2>SecurityFilter</h2>

<p>The <code>SecurityFilter</code> class is simply a Tinyweb filter that performs the request validation for authentication.  Nothing special here move along now.</p>

<h1>For Now and Up Next</h1>

<p>So thats all there is for now.  Code is, as I've said, available at the <a href="https://bitbucket.org/kouphax/tinyweb-fluentsecurity">BitBucket repository</a>.  I'm starting to build up some docs and stuff now and maybe tweak and add useful features.  If there is anything you would like to see raise it as an <a href="https://bitbucket.org/kouphax/tinyweb-fluentsecurity/issues?status=new&amp;status=open">issue</a> and I'll get around to it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tinkering with Agility: Honorable Mentions]]></title>
    <link href="http://yobriefca.se/blog/2011/09/02/tinkering-with-agility-honorable-mentions/"/>
    <updated>2011-09-02T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/09/02/tinkering-with-agility-honorable-mentions</id>
    <content type="html"><![CDATA[<p>In the process of <a href="/blog/2011/09/01/tinkering-with-agility/">researching Agility</a> I needed to throw together a quick serverside stack to accept the RESTful calls from Agility.  I went with my current framework de jour <a href="https://github.com/martinrue/Tinyweb">Tinyweb</a> and I must admit it was a great call.  For more basic info on Tinyweb check out my <a href="/blog/2011/07/18/micro-web-frameworks-101-tinyweb/">blog post</a></p>

<p>Agility by default routes the RESTful requests to <code>api/model/{id}</code> and Tinyweb let me create a handler associated with this sort of url by way of areas.</p>

<h2>Areas</h2>

<p>Tinyweb has a feature I wasn;t aware of before.  It is possible to register a handlers namespace as an "area" (if you have experience with ASP.NET MVC you'll know what that means).</p>

<pre><code>Tinyweb.Areas.Add("Agility.Tinkerings.Web.Handlers.Api", "api");
</code></pre>

<p>This means that even though my handler is call <code>TodoHandler</code> the url would map to the one above without having to sacrifice naming style of the handler or force us to create a custom route variable in each handler that had to map to this area.  Flippin clever stuff</p>

<h2>WebActivator</h2>

<p>Another excellent Nuget package is the <a href="http://nuget.org/List/Packages/WebActivator">WebActivator</a> and I have been charmed by it's slickness recently.  WebActivator allows you to attribute a class/namespace and specify what code should be run when the application starts.  So rather than having to put in a load of lines for configuring different aspects of your stack into <code>Global.asax.cs</code> you can break them into distinct classes and avoid breaking <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a> more than you have too.  Here is the example I used in the Agility.js source</p>

<pre><code>[assembly: WebActivator.PostApplicationStartMethod(typeof(TinywebActivator), "Activate")]
namespace Agility.Tinkerings.Web.Activators
{
    public class TinywebActivator
    {
        public static void Activate()
        {
            Tinyweb.Areas.Add("Agility.Tinkerings.Web.Handlers.Api", "api");
            Tinyweb.Init();
        }
    }
} 
</code></pre>

<p> I don't even have a <code>Global.asax</code> defined at all.</p>

<p> Feel free to poke around the source to get a better picture of how I threw the backend together.  Thanks go to <a href="https://github.com/martinrue/Tinyweb">Tinyweb</a> and <a href="http://twitter.com/#!/martinrue">@martinrue</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Micro Web Frameworks in .NET 101: Tinyweb]]></title>
    <link href="http://yobriefca.se/blog/2011/07/18/micro-web-frameworks-101-tinyweb/"/>
    <updated>2011-07-18T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/07/18/micro-web-frameworks-101-tinyweb</id>
    <content type="html"><![CDATA[<p>  <blockquote class="announce">This post is the is part of series of posts covering the various <em>micro web frameworks</em> in the .<span class="caps">NET</span> world.  The frameworks I intend to cover will be linked as the series progresses.  For further discussion on the use of micro web framework in .<span class="caps">NET</span> please see my <a href="http://yobriefca.se/blog/2011/05/18/why-use-micro-web-frameworks-in-net/">previous post</a> The current series line up:<ul>    <li><a href="http://yobriefca.se/blog/2011/05/19/micro-web-frameworks-101-jessica/">Jessica</a></li>    <li><a href="http://yobriefca.se/blog/2011/05/23/micro-web-frameworks-101-nancy/">Nancy</a></li>    <li><a href="http://yobriefca.se/blog/2011/06/22/micro-web-frameworks-101-anna/">Anna</a></li>  <li><a href="http://yobriefca.se/blog/2011/07/18/micro-web-frameworks-101-tinyweb//">Tinyweb</a><br></li></ul></blockquote><p>Tinyweb takes a slightly different view than the other web frameworks I have talked about.  In fact it takes a fairly opinionated approach to the way your structure your applications code and forces you to think in terms of resource endpoints rather then big monolithic modules or controllers.  It&#8217;s certainly true that projects based on the other frameworks such as Nancy and Jessica can be architected in such a way but Tinyweb ensures that you don&#8217;t start cutting corners and making allowances for lazy code by simply not providing the ability to do it!</p><h2>Getting Started &#8211; Hello World</h2><p>Lets get Tinyweb first from good old reliable Nuget,</p><script src='https://gist.github.com/1101809.js?file=Install.ps1'></script><noscript><pre><code>Install-Package Tinyweb</code></pre></noscript> <p>With Tinyweb installed we can go ahead and create a <code>RootHandler</code> this name is the one exception to the Tinyweb handler naming convention which I&#8217;ll touch on in a minute.</p><script src='https://gist.github.com/1101814.js?file=RootHandler.cs'></script><noscript><pre><code>public class RootHandler{    public IResult Get()    {        return Result.String("Hello World");    }}</code></pre></noscript><p>In our handler I also defined the a <code>Get</code> method which returns an IResult this will act as our endpoint.  One last thing before we magic up a web page is to initialise Tinyweb via our <code>Global.asax.cs</code> so Tinyweb can do its bootstrapping discovery voodoo stuffs.</p><script src='https://gist.github.com/1101802.js?file=Global.asax.cs'></script><noscript><pre><code>public class Global : HttpApplication{    protected void Application_Start(object sender, EventArgs e)    {        Tinyweb.Init();    }}</code></pre></noscript> <p>Et voila! Run the app and once again we have a hello world.</p><h2>Tinyweb Features</h2><p>Even in that small Hello World example there are plenty of Tinyweb features but you&#8217;ll also notice that Tinyweb really doesn&#8217;t get in the way at all.</p><h3>Handlers</h3><p>Each Tinyweb Handler represents a single resource endpoint.  With the exception of <code>RootHandler</code> the <span class="caps">URL</span> endpoint for each handler is inferred from the name of the handler.  For example a handler named <code>HelloHandler</code> will react to <code>/hello</code>, <code>HelloWorldHandler</code> will react to <code>/hello/world</code>.  You can see from these examples that casing of the handler name is important in terms of the url endpoint generation.</p><p>The next thing about handlers is that they respond to 4 methods each one corresponding to the 4 main Http Verbs &#8211; <code>Get()</code>, <code>Post()</code>, <code>Put()</code> and <code>Delete</code> &#8211; the only requirement of these is that they return an <code>IResult</code></p><h3>Model Binding and Arguments</h3><p>Model binding is also provided by handlers actions &#8211; just pass in an object and Tinyweb will do it&#8217;s best to bind request values to this object (accepts primitives, collections and plain C# objects).</p><p>Alternatively if you want to do some work under the hood you can make sure the <code>RequestContext</code> is passed in by simply passing it instead.  This gives you access to the bowels of the request to do with what you please.</p><h3>Advanced Routes</h3><p>It&#8217;s also possible to override the default routing convention by declaring a handler level variable called <code>route</code> of type <code>Route</code>.  This example shows how we can override handlers default route <code>/hello/world</code> and go with the more understandable &#8220;/helloworld&#8221;.</p><script src='https://gist.github.com/1102490.js?file=HelloWorldHandler.cs'></script><noscript><pre><code>public class HelloWorldHandler{    Route route = new Route("helloworld");    public IResult Get()    {        return Result.String("Hello World");    }}</code></pre></noscript><h3>Route Parameters</h3><p>In the spirit of RESTFulness you may also want to accept parameters as part of your <span class="caps">URL</span> and we can do that as well with this <code>route</code> class as well as optionally suppling default values for parameters,</p><script src='https://gist.github.com/1102494.js?file=HelloWorldHandler.cs'></script><noscript><pre><code>public class HelloWorldHandler{    Route route = new Route("hello/{name}");    // OR WITH A DEFAULT VALUE FOR PARAMS    Route route = new Route("hello/{name}", new { name = "World" });    public IResult Get(string name)    {        return Result.String("Hello " + name);    }}</code></pre></noscript><p>A powerful little approach.</p><h3>Results</h3><p>All Tinyweb results (e.g. what the response returns) implement the <code>IResult</code> interface so it&#8217;s simple enough to implement your own custom result type though it is probably unnecessary for the most part as Tinyweb offers a range of result types straight away via the <code>Result</code> classes static methods.</p><ul> <li>String</li> <li>File</li>   <li>Json</li>   <li><span class="caps">XML</span></li>  <li>JsonOrXml (returns either Json or <span class="caps">XML</span> depending on the request headers)</li>  <li>Html</li>   <li>Redirect (to a specific handler or <span class="caps">URL</span>)</li></ul><p>Tinyweb also offers a <code>View</code> class that can render views written with Spark and Razor so rendering a view can be as simple as</p><script src='https://gist.github.com/1102510.js?file=HelloWorldHandler.cs'></script><noscript><pre><code>public class HelloWorldHandler{    Route route = new Route("hello/{name}", new { name = "World" });    public IResult Get(string name)    {        return View.Razor&lt;string&gt;(name, "hello.cshtml");    }}</code></pre></noscript><h3>Filters</h3><p>Filters allow us to intercept requests both before and after they are processed on both a per handler and global level.</p><p>Each handler can optionally contain an <code>After</code> and/or a <code>Before</code> method that will, not surprisingly, be called after and before each handler request (I&#8217;ll let you guess which one does which) e.g.</p><script src='https://gist.github.com/1102652.js?file=RootHandler.cs'></script><noscript><pre><code>public class RootHandler{    public void Before()    {        Logger.Log("Before Executed");    }    public IResult Get()    {        return Result.String("Hello World");    }    public void After()    {        Logger.Log("After Executed");    }}</code></pre></noscript><p>Alternatively if you want the same before or after filter applied across all handlers you can create a Filter class by creating a class appended with the word <code>Filter</code>.  We can recreate the same handler above with a global filter for logging,</p><script src='https://gist.github.com/1102658.js?file=Filter.cs'></script><noscript><pre><code>public class LoggingFilter{    public void Before()    {        Logger.Log("Before Executed");    }    public void After()    {        Logger.Log("After Executed");    }}public class RootHandler{    public IResult Get()    {        return Result.String("Hello World");    }}</code></pre></noscript><p><code>Before</code> and <code>After</code> methods can also return <code>IResult</code> objects if you want to work with the actual response.</p><h3>Error Handling and Debugging</h3><p>Not all of us write flawless code and so sometimes things go south and exceptions start throwing their weight around.  Tinyweb has a global hook that is useful for capturing such errors as they bubble up to the surface.  The TinyWeb class has a static property <code>OnError</code> that accepts an Action that can be used to handle the exception e.g.</p><script src='https://gist.github.com/1102667.js?file=Global.asax.cs'></script><noscript><pre><code>protected void Application_Start(object sender, EventArgs e){    Tinyweb.Init();    Tinyweb.OnError = (exception, context, data) =&gt;    {        Logger.Log(exception);    };}</code></pre></noscript><p>Another useful tool when debugging your app is the <code>Tinyweb.WhatHaveIGot()</code>.  It&#8217;s a convenience method that can be used to print out all the matched routes and filters.</p><h2>Conclusion</h2><p>On the surface the focus of Tinyweb may seem only moderately different from other frameworks but after playing with it for a while it become apparent that the opinionated approach really makes you think about your projects structure and <span class="caps">API</span>.  I&#8217;m certainly of the opinion that this is a damn good thing<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>.  Tinyweb gives me just enough framework to do pretty much everything I need &#8211; which I would expect from a real micro-framework.  On top of that it&#8217;s flexible and intuitive and another handy utility in my tool belt.</p><p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> I&#8217;ve already said that it is possible to make the likes of Nancy and Jessica behave in this, either by ensuring that all module adhere to this pattern, or creating an abstract base class that enforces this sort of structure so I am in no way bashing the alternatives.  I like choice.</p></p>
]]></content>
  </entry>
  
</feed>
