<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>JSON | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/json/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2012-03-28T13:57:36+01:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Serialising .NET Resources to JSON for Web Apps]]></title>
    <link href="http://yobriefca.se/blog/2011/03/29/serialising-net-resources-to-json-for-web-apps/"/>
    <updated>2011-03-29T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2011/03/29/serialising-net-resources-to-json-for-web-apps</id>
    <content type="html"><![CDATA[<p>  <p>Pop quiz hotshot &ndash; you are building one of them massive single page web apps  using something like Sencha where the vast majority of work is pushed into the  JavaScript realm and some crazy nut wants everything localised or at least  all text strings push to RESX files.  What do you do?  WHAT DO YOU DO?</p><h2>Option 1</h2><p>Well the most obvious option, and IMHO the most horrible, would be to convert  all those JavaScript files into aspx&rsquo;s or cshtml&rsquo;s or whatever and embed the  resource references directly into the files.</p><p><script src="https://gist.github.com/892038.js"></script></p><p>This is far from nice.  For one it kind of makes any static compression of  the files either impossible or at best annoyingly fiddly.  It also prevents any  sort of quick client side caching unless you use some sort of VaryByCulture  Output Caching strategy on the server side.  Blegh.</p><h2>Option 2</h2><p>The next option, and certainly much better would be to pull out the direct  &lt;%= %&gt; references and store them in another smaller file and reference  them through a global JS object</p><p><script src="https://gist.github.com/892054.js"></script></p><p><script src="https://gist.github.com/892048.js"></script></p><p>This is nicer because it means you can compress and cache the JavaScript file  globally without having to worry about different cultures etc.  It does leave  one annoyance though.  The Strings object above it essentially boiler plate.   The names are a 1:1 mapping of the resource file so we have introduced a layer  of abstraction we have to write manually leaving us open to make some mistakes.   Slightly less blegh, but still blegh.</p><h2>Option 3</h2><p>The solution I like the best is to provide a mechanism for serialising the  Resource file into the equivalent JSON object.  You get all the benefits of  option 2 while not having to worry about having to write the mapping file.  So  lets keep the JS file from the second option and change the ASPX file</p><p><script src="https://gist.github.com/892069.js"></script></p><p>Now lets look at the magic behind this option &ndash; the JSON Serialiser</p><p><script src="https://gist.github.com/891939.js"></script></p><p>Simple enough little class that is configurable by Culture etc. so you can  pull different translation out on demand if needs be.  Obviously it doesn&rsquo;t do  anything around caching - SRP and all that stuff you know :-P</p><p>Yeah so I&rsquo;ve used this on 2 projects already with great success so hopefully  someone else finds it useful.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Better JSON Serialisation for ASP.NET MVC]]></title>
    <link href="http://yobriefca.se/blog/2010/11/20/better-json-serialisation-for-asp-net-mvc/"/>
    <updated>2010-11-20T00:00:00+00:00</updated>
    <id>http://yobriefca.se/blog/2010/11/20/better-json-serialisation-for-asp-net-mvc</id>
    <content type="html"><![CDATA[<p>  <p><p>The Json() method of controllers is a nice little convenience method for  serialising server side data into JSON for handy consumption on the client side  but it&rsquo;s not without it&rsquo;s issues.&nbsp; Firstly it just cant serialise dates in any  nice way due to no hard and fast standard in JSON for dates.</p><p><script src="https://gist.github.com/708168.js"></script></p><p>Simply gets spat back to the front end as a string like so,</p><p><script src="https://gist.github.com/708170.js"></script></p><p>Not exactly the most useful thing in the world. &nbsp;You are going to need to make use of JSON's reviver callback to parse this accordingly.</p><p>Another issue is lack of configurability.&nbsp; C# coding standards recommend the  use of PascalCased property names whereas in JavaScript land the standard is  camelCase (and many frameworks assume this casing which can cause issues behind  the scenes <em>cough</em>ExtJS<em>cough</em>).&nbsp; You can fix this by adding DataContract and  DataMember attributes to your model object but it gets a bit messy and open to  error if an attribute is left out accidentally.&nbsp; Or what if you don&rsquo;t have  access to the model code?</p><h2>JSON.NET</h2><p><a href="http://json.codeplex.com/">Json.NET</a> is my JSON de/serialiser of  choice.&nbsp; It&rsquo;s fast and widely configurable plus it fixes the problems I&rsquo;ve  mentioned above (among many many other things).&nbsp; Not to mention some BSON  (Binary JSON) support which could come in handy in the future.</p><h2>JsonNetResult</h2><p>So lets fix things.&nbsp; Lets wrap Json.NET up in an ActionResult type and offer  a configurable entry point.</p><p><script src="https://gist.github.com/708173.js"></script></p><p>As you can see I have exposed the JsonSerializerSettings object allow  developers to tune the serialisation all they want.&nbsp; We can also make things  even simpler by providing a Controller extension method that we can call without  having to create the object directly,</p><p><script src="https://gist.github.com/708175.js"></script></p><p>Simple stuff but still pretty powerful, lets see it in action.</p><h2>The Date Problem</h2><p>We can fix the date problem in a number of ways via converters.&nbsp; Converters  give us a custom way to convert values of objects and Json.NET provides a number  of converters out of the box &ndash; IsoDateTimeConverter, JavaScriptDateTimeConverter  and an abstract base DateTimeConverter to roll your own.&nbsp; Lets use the  JavaScriptDateTimeConverter for this example,</p><p><script src="https://gist.github.com/708176.js"></script></p><p>The resultant JSON object will generate a JSON object with a JavaScript Date  constructor</p><p><script src="https://gist.github.com/708178.js"></script></p><p>While not strictly valid JSON native JSON parsers and JSON2 handle it  fine.</p><h2>The Casing Issue</h2><p>We can use Json.NET&rsquo;s contract resolver to automagically convert PascalCased  property names of C# to camelCased property names of JavaScript.</p><p><script src="https://gist.github.com/708179.js"></script></p><p>Which gives us a response like so,</p><p><script src="https://gist.github.com/708183.js"></script></p><p>Fixed.</p><h2>Wrap Up</h2><p>So we have managed to create a much more powerful JSON serialisation  technique without having to sacrifice too much of the convenience of the Json()  method in the controller.&nbsp; Anyone got any recommendations/enhancements they are  willing to share? &nbsp;</p></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.NET MVC3 JsonValueProviderFactory]]></title>
    <link href="http://yobriefca.se/blog/2010/10/21/asp-net-mvc3-jsonvalueproviderfactory/"/>
    <updated>2010-10-21T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2010/10/21/asp-net-mvc3-jsonvalueproviderfactory</id>
    <content type="html"><![CDATA[<p>  <p><a href="http://www.asp.net/mvc/mvc3" target="_blank">ASP.NET MVC 3</a></p><p>Anyone who&rsquo;s been involved in an&nbsp;ASP.NET MVC project that is quite Ajax heavy  will probably have noticed that something was always missing.&nbsp; Imagine this  front end scenario,</p><p><script src="https://gist.github.com/639171.js"></script></p><p>Which posts to the following action</p><p><script src="https://gist.github.com/639226.js"></script></p><p>We have a login screen that is submitted via ajax.&nbsp; Now this is quite a  contrived example (ideally you&rsquo;d be&nbsp;performing a normal post via ajax in  this&nbsp;situation) but there are many instances where this sort practise would  apply (ExtJS&rsquo; RESTful DataWriters for example).&nbsp;</p><h2>MVC 2</h2><p>In MVC 2 this wouldn&rsquo;t work immediately.&nbsp; The default model binder in MVC 2  uses Request parameters to bind&nbsp;to model properties but in this case there are  none as the ajax content is the body of the request.</p><p>To accommodate this sort of request in MVC 2 we had to provide a custom model  binder that knows how to deal with JSON requests,</p><p><script src="https://gist.github.com/639234.js"></script></p><p>And attribute our actions model argument telling it to use this binder,</p><p><script src="https://gist.github.com/639242.js"></script></p><p>It&rsquo;ll do the job but it&rsquo;s incredibly messy.&nbsp;</p><h2>MVC 3</h2><p>MCV3 fills this gap thanks to the JsonValueProviderFactory.&nbsp; The JVPF  operates at a higher level than a model binder.&nbsp; Basically what it does when a  JSON request is received is that it pulls the values&nbsp;out of the JSON body&nbsp;as key  value pairs which means they are available to the model binders including the  default model binder.&nbsp; No special wiring required, no custom model binders  (unless of course you want one) just out-of-the-box workingness!</p><p><script src="https://gist.github.com/639226.js"></script></p><p>I know most of this post was taken up by MVC2 specific implementation but  isn&rsquo;t that really the point?&nbsp; MVC3 is a nice refinement of MVC2 there isn&rsquo;t  anything new exactly but the core stuff that is there has been made easier and  more configurable.</p></p>
]]></content>
  </entry>
  
</feed>
