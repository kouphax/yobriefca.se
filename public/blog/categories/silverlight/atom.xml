<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[<span class="label" style="margin-right:10px;"><a href="/" style="text-decoration:none; text-transform:none; color:#fff">&larr;</a></span>Silverlight | Yo Briefcase!]]></title>
  <link href="http://yobriefca.se/blog/categories/silverlight/atom.xml" rel="self"/>
  <link href="http://yobriefca.se/"/>
  <updated>2012-03-20T11:38:48+00:00</updated>
  <id>http://yobriefca.se/</id>
  <author>
    <name><![CDATA[James Hughes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Multi-Touch Reactive Extensions]]></title>
    <link href="http://yobriefca.se/blog/2010/10/18/multi-touch-reactive-extensions/"/>
    <updated>2010-10-18T00:00:00+01:00</updated>
    <id>http://yobriefca.se/blog/2010/10/18/multi-touch-reactive-extensions</id>
    <content type="html"><![CDATA[<p>  <p>Link:&nbsp;<a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET</a></p><p>It&rsquo;s been a while since I&rsquo;ve played with MultiTouch functionality so I decided it was time to dust off the old TouchSmart and put it to good use.&nbsp;&nbsp;The purpose wasn&rsquo;t to play with MultiTouch functionality but more to see how we could simplify managing isolated events using <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">RX</a>.&nbsp; The MultiTouch API is good for this because by its very nature MultiTouch requires us to collect multiple events simultaneously and wire them up to create gestures.&nbsp; Unfortunately the current iteration of MultiTouch API wrappers for Silverlight and WPF (<a href="http://touch.codeplex.com/">touch</a>, <a href="http://miria.codeplex.com/">MIRIA</a>&nbsp;etc) are quite basic and when working with custom gestures you are forced to introduce a lot of global code such as flags etc.&nbsp; Not pretty!</p><p>Imagine the following scenario.</p><ul><li>2 touch points on screen (let call them HoldRight and HoldLeft).&nbsp; Both expose 2 events Hold and Release</li><li>When a person presses and hold a finger over BOTH points trigger an event</li><li>If only one is being pressed and held do not fire the event</li><li>If the user lifts their finger or fingers off the points and repeats the process the event should fire again.</li></ul><p>This is a fairly simple example but actually wiring this up requires the use of nasty global variables and a bit of repetition.&nbsp; Here is a very quick implementation of this.</p><p><script src="https://gist.github.com/632785.js"></script></p><p>As you can see I have made use of 2 global variables a DoCheck method that checks if the 2 canvases are currently in a &ldquo;held&rdquo; state and fires the event if they are.&nbsp; All the event handlers do nearly the same thing.&nbsp; Sure I could refactor this to use maybe 2 event handlers and inspect the sender but that starts getting messy.</p><h2>Reactive Extensions to the Rescue!</h2><p>Reactive extensions let us &ldquo;compose&rdquo; events so we can pass them around and filter them like first class citizens.&nbsp; Because of this we can actually create custom events by combining.&nbsp; Tackling the same issue as above we can achieve the same functionality without the need for dodgy global vars and boilerplate code.&nbsp; Lets look at the code first.</p><p><script src="https://gist.github.com/632781.js"></script></p><p>First things first for some random reason the implementers of MIRIA decided to create en event the actually passed NO event args &ndash; this is not normal and could easily be considered and anti-pattern.&nbsp; Because of this I had to use the long winded Observable.FromEvent which is created as a helper method.</p><p>So what are we doing here?</p><ol><li>Compose our events into first class citizens &ndash; Observables</li><li>Zip left and right hold events.&nbsp; Zipping basically combines 2 Observables and publishes or emits a value when both observables have emitted a value.&nbsp; The second argument in Zip is the transform function that converts the 2 emitted values into 1 value.&nbsp; We don&rsquo;t care about this value so just return some arbitrary value.</li><li>Take the Zip generated observable and keep publishing it&rsquo;s values until Either the left or right release events are triggers (Amb = most ambitious &ndash; publishes first value to appear)</li><li>Subscribe to this super composed event.&nbsp; When this happens we can fire our event</li></ol><p>What actually happens on the front end is irrelevant (the solution looks like this and will spin when the two Thumb areas are pressed and held)</p><p>[[posterous-content:ECxarBiHmvIvJutnbJaJ]]</p><p>But the fact we have managed to combine 4 isolated events without having to use boilerplate is very nice.&nbsp; This gives us a lot of power to create and control complex gestures &ndash; not limited to MultiTouch but any sort of UI interactions (Mouse events, Web service calls etc).</p><p><em>* I&rsquo;ll keep saying this.&nbsp; RX doesn&rsquo;t do anything new or solve any unsolvable problems but what it does do is allow us to do things in a neater way.&nbsp; Now there is a bit of learning curve in it &ndash; you really need to start thinking in RX but once you wrap your head around RX is a nice tool to have on your tool belt.&nbsp; No it&rsquo;s not complexity for complexity&rsquo;s sake &ndash; I honestly believe the code above, when used in the real world, will hep reduce complexity and make maintenance easier.</em></p><p>Good Fortune Awaits!</p></p>
]]></content>
  </entry>
  
</feed>
